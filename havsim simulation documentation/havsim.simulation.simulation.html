<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module havsim.simulation.simulation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="havsim.html"><font color="#ffffff">havsim</font></a>.<a href="havsim.simulation.html"><font color="#ffffff">simulation</font></a>.simulation</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:c%3A%5Cusers%5Crlk268%5Conedrive%20-%20cornell%20university%5Chav-sim%5Chavsim%5Csimulation%5Csimulation.py">c:\users\rlk268\onedrive - cornell university\hav-sim\havsim\simulation\simulation.py</a></font></td></tr></table>
    <p><tt>Houses&nbsp;the&nbsp;main&nbsp;code&nbsp;for&nbsp;running&nbsp;simulations.<br>
&nbsp;<br>
A&nbsp;simulation&nbsp;is&nbsp;defined&nbsp;by&nbsp;a&nbsp;collection&nbsp;of&nbsp;lanes/roads&nbsp;(a&nbsp;road&nbsp;network)&nbsp;and&nbsp;an&nbsp;initial<br>
collection&nbsp;of&nbsp;vehicles.&nbsp;The&nbsp;road&nbsp;network&nbsp;defines&nbsp;both&nbsp;the&nbsp;network&nbsp;topology&nbsp;(i.e.&nbsp;how&nbsp;roads&nbsp;connect<br>
with&nbsp;each&nbsp;other)&nbsp;as&nbsp;well&nbsp;as&nbsp;the&nbsp;inflow/outflow&nbsp;boundary&nbsp;conditions,&nbsp;which&nbsp;determine&nbsp;how<br>
vehicles&nbsp;enter/leave&nbsp;the&nbsp;simulation.&nbsp;The&nbsp;inflow&nbsp;conditions&nbsp;additionally&nbsp;control&nbsp;what&nbsp;types&nbsp;of<br>
vehicles&nbsp;enter&nbsp;the&nbsp;simulation.&nbsp;Vehicles&nbsp;are&nbsp;implemented&nbsp;in&nbsp;the&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;class&nbsp;and&nbsp;a&nbsp;road&nbsp;network<br>
is&nbsp;made&nbsp;up&nbsp;of&nbsp;instances&nbsp;of&nbsp;the&nbsp;<a href="#Lane">Lane</a>&nbsp;class.</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="havsim.simulation.models.html">havsim.simulation.models</a><br>
</td><td width="25%" valign=top><a href="math.html">math</a><br>
</td><td width="25%" valign=top><a href="numpy.html">numpy</a><br>
</td><td width="25%" valign=top><a href="scipy.optimize.html">scipy.optimize</a><br>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="havsim.simulation.simulation.html#AnchorVehicle">AnchorVehicle</a>
</font></dt><dt><font face="helvetica, arial"><a href="havsim.simulation.simulation.html#Lane">Lane</a>
</font></dt><dt><font face="helvetica, arial"><a href="havsim.simulation.simulation.html#Simulation">Simulation</a>
</font></dt><dt><font face="helvetica, arial"><a href="havsim.simulation.simulation.html#Vehicle">Vehicle</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="AnchorVehicle">class <strong>AnchorVehicle</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#AnchorVehicle">AnchorVehicle</a>(curlane,&nbsp;inittime,&nbsp;lead=None,&nbsp;rlead=None,&nbsp;llead=None)<br>
&nbsp;<br>
Anchors&nbsp;are&nbsp;'dummy'&nbsp;Vehicles&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;as&nbsp;placeholders&nbsp;(e.g.&nbsp;at&nbsp;the&nbsp;beginning/end&nbsp;of&nbsp;Lanes).<br>
&nbsp;<br>
Anchors&nbsp;are&nbsp;used&nbsp;at&nbsp;the&nbsp;beginning&nbsp;of&nbsp;Lanes,&nbsp;to&nbsp;maintain&nbsp;vehicle&nbsp;order,&nbsp;so&nbsp;that&nbsp;vehicles&nbsp;will&nbsp;have<br>
a&nbsp;correct&nbsp;vehicle&nbsp;order&nbsp;upon&nbsp;being&nbsp;added&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;lane.&nbsp;Because&nbsp;of&nbsp;anchors,&nbsp;it&nbsp;is&nbsp;not<br>
possible&nbsp;for&nbsp;vehicles&nbsp;to&nbsp;have&nbsp;None&nbsp;as&nbsp;a&nbsp;fol/lfol/rfol&nbsp;attribute&nbsp;(unless&nbsp;the&nbsp;left/right&nbsp;lane&nbsp;don't&nbsp;exist).<br>
Anchors&nbsp;can&nbsp;also&nbsp;be&nbsp;used&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;lanes,&nbsp;e.g.&nbsp;to&nbsp;simulate&nbsp;vehicles&nbsp;needing&nbsp;to&nbsp;stop&nbsp;because<br>
of&nbsp;a&nbsp;traffic&nbsp;light&nbsp;or&nbsp;because&nbsp;the&nbsp;lane&nbsp;ends.<br>
All&nbsp;Lanes&nbsp;have&nbsp;an&nbsp;anchor&nbsp;attribute&nbsp;which&nbsp;is&nbsp;an&nbsp;<a href="#AnchorVehicle">AnchorVehicle</a>&nbsp;at&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;Lanes'&nbsp;track.&nbsp;A&nbsp;track<br>
is&nbsp;a&nbsp;continuous&nbsp;series&nbsp;of&nbsp;lanes&nbsp;such&nbsp;that&nbsp;a&nbsp;vehicle&nbsp;can&nbsp;travel&nbsp;on&nbsp;all&nbsp;the&nbsp;constituent&nbsp;lanes&nbsp;without<br>
performing&nbsp;any&nbsp;lane&nbsp;changes&nbsp;(i.e.&nbsp;the&nbsp;end&nbsp;of&nbsp;any&nbsp;lane&nbsp;in&nbsp;the&nbsp;track&nbsp;connects&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;next<br>
lane&nbsp;in&nbsp;the&nbsp;track).&nbsp;Therefore&nbsp;comparing&nbsp;<a href="#Lane">Lane</a>'s&nbsp;anchors&nbsp;can&nbsp;also&nbsp;be&nbsp;used&nbsp;to&nbsp;compare&nbsp;their&nbsp;tracks.<br>
Compared&nbsp;to&nbsp;Vehicles,&nbsp;Anchors&nbsp;don't&nbsp;have&nbsp;a&nbsp;cf&nbsp;or&nbsp;lc&nbsp;model,&nbsp;have&nbsp;much&nbsp;fewer&nbsp;attributes,&nbsp;and&nbsp;don't&nbsp;have<br>
any&nbsp;methods&nbsp;which&nbsp;update&nbsp;their&nbsp;attributes.<br>
The&nbsp;way&nbsp;we&nbsp;check&nbsp;for&nbsp;anchors&nbsp;is&nbsp;because&nbsp;they&nbsp;have&nbsp;cf_parameters&nbsp;=&nbsp;None.<br>
&nbsp;<br>
Attributes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;cf_parameters:&nbsp;Always&nbsp;None,&nbsp;used&nbsp;to&nbsp;identify&nbsp;a&nbsp;vehicle&nbsp;as&nbsp;being&nbsp;an&nbsp;anchor<br>
&nbsp;&nbsp;&nbsp;&nbsp;lane,&nbsp;road,&nbsp;lfol,&nbsp;rfol,&nbsp;lead,&nbsp;rlead,&nbsp;llead,&nbsp;all&nbsp;have&nbsp;the&nbsp;same&nbsp;meaning&nbsp;as&nbsp;for&nbsp;<a href="#Vehicle">Vehicle</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;position&nbsp;anchor&nbsp;is&nbsp;on,&nbsp;used&nbsp;for&nbsp;headway/dist&nbsp;calculations<br>
&nbsp;&nbsp;&nbsp;&nbsp;speed:&nbsp;speed&nbsp;of&nbsp;anchor,&nbsp;can&nbsp;be&nbsp;used&nbsp;if&nbsp;anchor&nbsp;is&nbsp;used&nbsp;as&nbsp;a&nbsp;leader&nbsp;for&nbsp;a&nbsp;<a href="#Vehicle">Vehicle</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;hd:&nbsp;always&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;len:&nbsp;length&nbsp;of&nbsp;anchor,&nbsp;should&nbsp;be&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;leadmem:&nbsp;same&nbsp;format&nbsp;as&nbsp;<a href="#Vehicle">Vehicle</a><br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="AnchorVehicle-__init__"><strong>__init__</strong></a>(self, curlane, inittime, lead=None, rlead=None, llead=None)</dt><dd><tt>Inits&nbsp;for&nbsp;Anchor.</tt></dd></dl>

<dl><dt><a name="AnchorVehicle-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Representation&nbsp;in&nbsp;ipython&nbsp;console.</tt></dd></dl>

<dl><dt><a name="AnchorVehicle-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Convert&nbsp;to&nbsp;string.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Lane">class <strong>Lane</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Lane">Lane</a>(start,&nbsp;end,&nbsp;road,&nbsp;laneind,&nbsp;connect_left=None,&nbsp;connect_right=None,&nbsp;connect_to=None,&nbsp;downstream=None,&nbsp;increment_inflow=None,&nbsp;get_inflow=None,&nbsp;new_vehicle=None)<br>
&nbsp;<br>
Basic&nbsp;building&nbsp;block&nbsp;for&nbsp;roads/road&nbsp;networks.<br>
&nbsp;<br>
Lanes&nbsp;are&nbsp;responsible&nbsp;for&nbsp;defining&nbsp;the&nbsp;topology&nbsp;(e.g.&nbsp;when&nbsp;lanes&nbsp;start/end,&nbsp;which&nbsp;lanes&nbsp;connect<br>
to&nbsp;what,&nbsp;what&nbsp;it&nbsp;is&nbsp;possible&nbsp;to&nbsp;change&nbsp;left/right&nbsp;into)&nbsp;and&nbsp;are&nbsp;responsible&nbsp;for&nbsp;doing&nbsp;headway/distance<br>
calculations&nbsp;between&nbsp;Vehicles.&nbsp;Positions&nbsp;are&nbsp;relative&nbsp;to&nbsp;the&nbsp;road&nbsp;a&nbsp;lane&nbsp;belongs&nbsp;to.<br>
They&nbsp;also&nbsp;define&nbsp;boundary&nbsp;conditions,&nbsp;and&nbsp;are&nbsp;responsible&nbsp;for&nbsp;creating&nbsp;new&nbsp;vehicles&nbsp;and&nbsp;adding&nbsp;them<br>
to&nbsp;the&nbsp;network.<br>
&nbsp;<br>
Attributes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;start:&nbsp;starting&nbsp;position&nbsp;of&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;end:&nbsp;ending&nbsp;position&nbsp;of&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;road:&nbsp;road&nbsp;dictionary&nbsp;<a href="#Lane">Lane</a>&nbsp;belongs&nbsp;to.&nbsp;A&nbsp;road&nbsp;has&nbsp;keys&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;string&nbsp;name&nbsp;of&nbsp;the&nbsp;road<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len:&nbsp;length&nbsp;of&nbsp;road<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;laneinds:&nbsp;number&nbsp;of&nbsp;Lanes&nbsp;which&nbsp;belong&nbsp;to&nbsp;the&nbsp;road<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lanes:&nbsp;every&nbsp;<a href="#Lane">Lane</a>&nbsp;belonging&nbsp;to&nbsp;the&nbsp;road&nbsp;is&nbsp;hashed&nbsp;by&nbsp;its&nbsp;laneind.&nbsp;Lanes&nbsp;are&nbsp;ordered&nbsp;left&nbsp;-&nbsp;right<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where&nbsp;the&nbsp;leftmost&nbsp;lane&nbsp;has&nbsp;index&nbsp;0&nbsp;and&nbsp;rightmost&nbsp;laneinds&nbsp;-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect&nbsp;to:&nbsp;tuple&nbsp;with&nbsp;information&nbsp;needed&nbsp;for&nbsp;routes,&nbsp;see&nbsp;make_cur_route<br>
&nbsp;&nbsp;&nbsp;&nbsp;roadname:&nbsp;string&nbsp;name&nbsp;of&nbsp;road<br>
&nbsp;&nbsp;&nbsp;&nbsp;laneind:&nbsp;index&nbsp;of&nbsp;<a href="#Lane">Lane</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;connect_left:&nbsp;defines&nbsp;left&nbsp;connections&nbsp;for&nbsp;<a href="#Lane">Lane</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;connect_right:&nbsp;defines&nbsp;right&nbsp;connections&nbsp;for&nbsp;<a href="#Lane">Lane</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;connect_to:&nbsp;what&nbsp;the&nbsp;end&nbsp;of&nbsp;<a href="#Lane">Lane</a>&nbsp;connects&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;anchor:&nbsp;<a href="#AnchorVehicle">AnchorVehicle</a>&nbsp;for&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;roadlen:&nbsp;defines&nbsp;distance&nbsp;between&nbsp;<a href="#Lane">Lane</a>'s&nbsp;road&nbsp;and&nbsp;other&nbsp;roads.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Lane-__eq__"><strong>__eq__</strong></a>(self, other)</dt><dd><tt>Comparison&nbsp;for&nbsp;Lanes&nbsp;using&nbsp;==.</tt></dd></dl>

<dl><dt><a name="Lane-__hash__"><strong>__hash__</strong></a>(self)</dt><dd><tt>Hash&nbsp;<a href="#Lane">Lane</a>&nbsp;based&nbsp;on&nbsp;its&nbsp;road&nbsp;name,&nbsp;and&nbsp;its&nbsp;lane&nbsp;index.</tt></dd></dl>

<dl><dt><a name="Lane-__init__"><strong>__init__</strong></a>(self, start, end, road, laneind, connect_left=None, connect_right=None, connect_to=None, downstream=None, increment_inflow=None, get_inflow=None, new_vehicle=None)</dt><dd><tt>Inits&nbsp;<a href="#Lane">Lane</a>.&nbsp;Note&nbsp;methods&nbsp;for&nbsp;boundary&nbsp;conditions&nbsp;are&nbsp;defined&nbsp;(and&nbsp;bound)&nbsp;here.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;start:&nbsp;starting&nbsp;position&nbsp;for&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;end:&nbsp;ending&nbsp;position&nbsp;for&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;road:&nbsp;road&nbsp;dictionary&nbsp;<a href="#Lane">Lane</a>&nbsp;belongs&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;laneind:&nbsp;unique&nbsp;index&nbsp;for&nbsp;<a href="#Lane">Lane</a>&nbsp;(unique&nbsp;to&nbsp;road)<br>
&nbsp;&nbsp;&nbsp;&nbsp;connect_left:&nbsp;list&nbsp;of&nbsp;tuples&nbsp;where&nbsp;each&nbsp;tuple&nbsp;is&nbsp;a&nbsp;(<a href="#Lane">Lane</a>&nbsp;or&nbsp;None,&nbsp;position)&nbsp;pair&nbsp;such&nbsp;that&nbsp;<a href="#Lane">Lane</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;the&nbsp;left&nbsp;connection&nbsp;of&nbsp;self&nbsp;starting&nbsp;at&nbsp;position.<br>
&nbsp;&nbsp;&nbsp;&nbsp;connect_right:&nbsp;list&nbsp;of&nbsp;tuples&nbsp;where&nbsp;each&nbsp;tuple&nbsp;is&nbsp;a&nbsp;(<a href="#Lane">Lane</a>&nbsp;or&nbsp;None,&nbsp;position)&nbsp;pair&nbsp;such&nbsp;that&nbsp;<a href="#Lane">Lane</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;the&nbsp;right&nbsp;connection&nbsp;of&nbsp;self&nbsp;starting&nbsp;at&nbsp;position.<br>
&nbsp;&nbsp;&nbsp;&nbsp;connect_to:&nbsp;<a href="#Lane">Lane</a>&nbsp;or&nbsp;None&nbsp;which&nbsp;a&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;transitions&nbsp;to&nbsp;after&nbsp;reaching&nbsp;end&nbsp;of&nbsp;<a href="#Lane">Lane</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;downstream:&nbsp;dictionary&nbsp;of&nbsp;keyword&nbsp;args&nbsp;which&nbsp;defines&nbsp;call_downstream&nbsp;method,&nbsp;or&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;increment_inflow:&nbsp;dictionary&nbsp;of&nbsp;keyword&nbsp;args&nbsp;which&nbsp;defines&nbsp;increment_inflow&nbsp;method,&nbsp;or&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;get_inflow:&nbsp;dictionary&nbsp;of&nbsp;keyword&nbsp;args&nbsp;which&nbsp;defines&nbsp;increment_inflow&nbsp;method,&nbsp;or&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;new_vehicle:&nbsp;function&nbsp;which&nbsp;is&nbsp;used&nbsp;as&nbsp;the&nbsp;new_vehicle&nbsp;method</tt></dd></dl>

<dl><dt><a name="Lane-__ne__"><strong>__ne__</strong></a>(self, other)</dt><dd><tt>Comparison&nbsp;for&nbsp;Lanes&nbsp;using&nbsp;!=.</tt></dd></dl>

<dl><dt><a name="Lane-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Representation&nbsp;in&nbsp;ipython&nbsp;console.</tt></dd></dl>

<dl><dt><a name="Lane-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Convert&nbsp;<a href="#Lane">Lane</a>&nbsp;to&nbsp;a&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Lane-get_connect_left"><strong>get_connect_left</strong></a>(self, pos)</dt><dd><tt>Takes&nbsp;in&nbsp;a&nbsp;position&nbsp;and&nbsp;returns&nbsp;the&nbsp;left&nbsp;connection&nbsp;(<a href="#Lane">Lane</a>&nbsp;or&nbsp;None)&nbsp;at&nbsp;that&nbsp;position.</tt></dd></dl>

<dl><dt><a name="Lane-get_connect_right"><strong>get_connect_right</strong></a>(self, pos)</dt><dd><tt>Takes&nbsp;in&nbsp;a&nbsp;position&nbsp;and&nbsp;returns&nbsp;the&nbsp;right&nbsp;connection&nbsp;(<a href="#Lane">Lane</a>&nbsp;or&nbsp;None)&nbsp;at&nbsp;that&nbsp;position.</tt></dd></dl>

<dl><dt><a name="Lane-get_dist"><strong>get_dist</strong></a>(self, veh, lead)</dt><dd><tt>Calculates&nbsp;distance&nbsp;from&nbsp;veh&nbsp;to&nbsp;the&nbsp;front&nbsp;of&nbsp;lead.&nbsp;Assumes&nbsp;veh.road&nbsp;=&nbsp;self.<strong>road</strong>.</tt></dd></dl>

<dl><dt><a name="Lane-get_headway"><strong>get_headway</strong></a>(self, veh, lead)</dt><dd><tt>Calculates&nbsp;distance&nbsp;from&nbsp;veh&nbsp;to&nbsp;the&nbsp;back&nbsp;of&nbsp;lead.&nbsp;Assumes&nbsp;veh.road&nbsp;=&nbsp;self.<strong>road</strong>.</tt></dd></dl>

<dl><dt><a name="Lane-leadfol_find"><strong>leadfol_find</strong></a>(self, veh, guess, side)</dt><dd><tt>Find&nbsp;the&nbsp;leader/follower&nbsp;for&nbsp;veh,&nbsp;in&nbsp;the&nbsp;same&nbsp;track&nbsp;as&nbsp;guess&nbsp;(can&nbsp;be&nbsp;a&nbsp;different&nbsp;track&nbsp;than&nbsp;veh's).<br>
&nbsp;<br>
Used&nbsp;primarily&nbsp;to&nbsp;find&nbsp;the&nbsp;new&nbsp;lcside&nbsp;follower&nbsp;of&nbsp;veh.&nbsp;Note&nbsp;that&nbsp;we&nbsp;can't&nbsp;use&nbsp;binary&nbsp;search&nbsp;because<br>
it's&nbsp;inefficient&nbsp;to&nbsp;store&nbsp;a&nbsp;sorted&nbsp;list&nbsp;of&nbsp;vehicles.&nbsp;Since&nbsp;we&nbsp;are&nbsp;just&nbsp;doing&nbsp;a&nbsp;regular&nbsp;search,&nbsp;guess<br>
should&nbsp;be&nbsp;close&nbsp;to&nbsp;the&nbsp;leader/follower.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;to&nbsp;find&nbsp;leader/follower&nbsp;of<br>
&nbsp;&nbsp;&nbsp;&nbsp;guess:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;in&nbsp;the&nbsp;track&nbsp;we&nbsp;want&nbsp;the&nbsp;leader/follower&nbsp;in.<br>
&nbsp;&nbsp;&nbsp;&nbsp;side:&nbsp;if&nbsp;side&nbsp;is&nbsp;not&nbsp;None,&nbsp;we&nbsp;make&nbsp;sure&nbsp;that&nbsp;the&nbsp;side&nbsp;leader&nbsp;can&nbsp;actually&nbsp;have&nbsp;veh&nbsp;as&nbsp;a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opside&nbsp;follower.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;(lead&nbsp;<a href="#Vehicle">Vehicle</a>,&nbsp;following&nbsp;<a href="#Vehicle">Vehicle</a>)&nbsp;in&nbsp;that&nbsp;order,&nbsp;for&nbsp;veh</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Simulation">class <strong>Simulation</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Simulation">Simulation</a>(inflow_lanes,&nbsp;merge_lanes,&nbsp;vehicles=None,&nbsp;all_vehicles=None,&nbsp;vehid=0,&nbsp;timeind=0,&nbsp;dt=0.25)<br>
&nbsp;<br>
Implements&nbsp;a&nbsp;traffic&nbsp;microsimulation.<br>
&nbsp;<br>
Basically&nbsp;just&nbsp;a&nbsp;wrapper&nbsp;for&nbsp;update_net.&nbsp;For&nbsp;more&nbsp;information&nbsp;on&nbsp;traffic<br>
microsimulation&nbsp;refer&nbsp;to&nbsp;the&nbsp;full&nbsp;documentation&nbsp;which&nbsp;has&nbsp;extra&nbsp;details&nbsp;and&nbsp;explanation.<br>
&nbsp;<br>
Attributes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;inflow&nbsp;lanes:&nbsp;list&nbsp;of&nbsp;all&nbsp;lanes&nbsp;which&nbsp;have&nbsp;inflow&nbsp;to&nbsp;them&nbsp;(i.e.&nbsp;all&nbsp;lanes&nbsp;which&nbsp;have&nbsp;upstream<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary&nbsp;conditions,&nbsp;meaning&nbsp;they&nbsp;can&nbsp;add&nbsp;vehicles&nbsp;to&nbsp;the&nbsp;simulation)<br>
&nbsp;&nbsp;&nbsp;&nbsp;merge_lanes:&nbsp;list&nbsp;of&nbsp;all&nbsp;lanes&nbsp;which&nbsp;have&nbsp;merge&nbsp;anchors<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehicles:&nbsp;set&nbsp;of&nbsp;all&nbsp;vehicles&nbsp;which&nbsp;are&nbsp;in&nbsp;the&nbsp;simulation&nbsp;at&nbsp;the&nbsp;first&nbsp;time&nbsp;index.&nbsp;This&nbsp;is&nbsp;kept<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updated&nbsp;so&nbsp;that&nbsp;vehicles&nbsp;is&nbsp;always&nbsp;the&nbsp;set&nbsp;of&nbsp;all&nbsp;vehicles&nbsp;currently&nbsp;being&nbsp;simulated.<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_vehicles:&nbsp;set&nbsp;of&nbsp;all&nbsp;vehicles&nbsp;which&nbsp;have&nbsp;been&nbsp;removed&nbsp;from&nbsp;simulation.&nbsp;So&nbsp;all_vehicles&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vehicles&nbsp;are&nbsp;disjoint&nbsp;sets,&nbsp;and&nbsp;their&nbsp;union&nbsp;contains&nbsp;all&nbsp;vehicles&nbsp;which&nbsp;have&nbsp;been&nbsp;simulated.<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehid:&nbsp;starting&nbsp;vehicle&nbsp;ID&nbsp;for&nbsp;the&nbsp;next&nbsp;vehicle&nbsp;to&nbsp;be&nbsp;added.&nbsp;Used&nbsp;for&nbsp;hashing&nbsp;vehicles.<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind:&nbsp;the&nbsp;current&nbsp;time&nbsp;index&nbsp;of&nbsp;the&nbsp;simulation&nbsp;(int).&nbsp;Updated&nbsp;as&nbsp;simulation&nbsp;progresses.<br>
&nbsp;&nbsp;&nbsp;&nbsp;dt:&nbsp;constant&nbsp;float.&nbsp;timestep&nbsp;for&nbsp;the&nbsp;simulation.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Simulation-__init__"><strong>__init__</strong></a>(self, inflow_lanes, merge_lanes, vehicles=None, all_vehicles=None, vehid=0, timeind=0, dt=0.25)</dt><dd><tt>Inits&nbsp;simulation.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;inflow_lanes:&nbsp;list&nbsp;of&nbsp;all&nbsp;Lanes&nbsp;which&nbsp;have&nbsp;inflow&nbsp;to&nbsp;them<br>
&nbsp;&nbsp;&nbsp;&nbsp;merge_lanes:&nbsp;list&nbsp;of&nbsp;all&nbsp;Lanes&nbsp;which&nbsp;have&nbsp;merge&nbsp;anchors<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehicles:&nbsp;set&nbsp;of&nbsp;all&nbsp;Vehicles&nbsp;in&nbsp;simulation&nbsp;in&nbsp;first&nbsp;timestep<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_vehicles:&nbsp;set&nbsp;of&nbsp;all&nbsp;Vehicles&nbsp;which&nbsp;were&nbsp;previously&nbsp;removed&nbsp;from&nbsp;simulation.<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehid:&nbsp;vehicle&nbsp;ID&nbsp;used&nbsp;for&nbsp;the&nbsp;next&nbsp;vehicle&nbsp;to&nbsp;be&nbsp;created.<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind):&nbsp;starting&nbsp;time&nbsp;index&nbsp;(int)&nbsp;for&nbsp;the&nbsp;simulation.<br>
&nbsp;&nbsp;&nbsp;&nbsp;dt:&nbsp;float&nbsp;for&nbsp;how&nbsp;many&nbsp;time&nbsp;units&nbsp;pass&nbsp;for&nbsp;each&nbsp;timestep.&nbsp;Defaults&nbsp;to&nbsp;.25.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;We&nbsp;keep&nbsp;references&nbsp;to&nbsp;all&nbsp;vehicles&nbsp;through&nbsp;vehicles&nbsp;and&nbsp;all_vehicles,&nbsp;vehicles&nbsp;store&nbsp;their&nbsp;own<br>
&nbsp;&nbsp;&nbsp;&nbsp;memory.</tt></dd></dl>

<dl><dt><a name="Simulation-reset"><strong>reset</strong></a>(self)</dt></dl>

<dl><dt><a name="Simulation-simulate"><strong>simulate</strong></a>(self, timesteps)</dt><dd><tt>Call&nbsp;step&nbsp;method&nbsp;timesteps&nbsp;number&nbsp;of&nbsp;times.</tt></dd></dl>

<dl><dt><a name="Simulation-step"><strong>step</strong></a>(self, timeind)</dt><dd><tt>Logic&nbsp;for&nbsp;doing&nbsp;a&nbsp;single&nbsp;step&nbsp;of&nbsp;simulation.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind&nbsp;(TYPE):&nbsp;current&nbsp;time&nbsp;index&nbsp;(int)&nbsp;for&nbsp;the&nbsp;simulation<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Vehicle">class <strong>Vehicle</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Vehicle">Vehicle</a>(vehid,&nbsp;curlane,&nbsp;cf_parameters,&nbsp;lc_parameters,&nbsp;lead=None,&nbsp;fol=None,&nbsp;lfol=None,&nbsp;rfol=None,&nbsp;llead=None,&nbsp;rlead=None,&nbsp;length=3,&nbsp;eql_type='v',&nbsp;relax_parameters=12,&nbsp;shift_parameters=None,&nbsp;coop_parameters=0.2,&nbsp;route_parameters=None,&nbsp;route=None,&nbsp;accbounds=None,&nbsp;maxspeed=10000.0,&nbsp;hdbounds=None)<br>
&nbsp;<br>
Base&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;class.&nbsp;Implemented&nbsp;for&nbsp;a&nbsp;second&nbsp;order&nbsp;ODE&nbsp;car&nbsp;following&nbsp;model.<br>
&nbsp;<br>
Vehicles&nbsp;are&nbsp;responsible&nbsp;for&nbsp;implementing&nbsp;the&nbsp;rules&nbsp;to&nbsp;update&nbsp;their&nbsp;positions.&nbsp;This&nbsp;includes&nbsp;a<br>
'car&nbsp;following'&nbsp;(cf)&nbsp;model&nbsp;which&nbsp;is&nbsp;used&nbsp;to&nbsp;update&nbsp;the&nbsp;longitudinal&nbsp;(in&nbsp;the&nbsp;direction&nbsp;of&nbsp;travel)&nbsp;position.<br>
There&nbsp;is&nbsp;also&nbsp;a&nbsp;'lane&nbsp;changing'&nbsp;(lc)&nbsp;model&nbsp;which&nbsp;is&nbsp;used&nbsp;to&nbsp;update&nbsp;the&nbsp;latitudinal&nbsp;(which&nbsp;lane)&nbsp;position.<br>
Besides&nbsp;these&nbsp;two&nbsp;fundamental&nbsp;components,&nbsp;Vehicles&nbsp;also&nbsp;need&nbsp;an&nbsp;update&nbsp;method,&nbsp;which&nbsp;updates&nbsp;their<br>
longitudinal&nbsp;positions&nbsp;and&nbsp;memory&nbsp;of&nbsp;their&nbsp;past&nbsp;(past&nbsp;memory&nbsp;includes&nbsp;any&nbsp;quantities&nbsp;which&nbsp;are&nbsp;needed<br>
to&nbsp;differentiate&nbsp;the&nbsp;simulation).<br>
Vehicles&nbsp;also&nbsp;contain&nbsp;the&nbsp;quantities&nbsp;lead,&nbsp;fol,&nbsp;lfol,&nbsp;rfol,&nbsp;llead,&nbsp;and&nbsp;rlead,&nbsp;(i.e.&nbsp;their&nbsp;vehicle<br>
relationships)&nbsp;which&nbsp;define&nbsp;the&nbsp;order&nbsp;of&nbsp;vehicles&nbsp;on&nbsp;the&nbsp;road,&nbsp;and&nbsp;is&nbsp;necessary&nbsp;for&nbsp;calling&nbsp;the&nbsp;cf<br>
and&nbsp;lc&nbsp;models.<br>
Vehicles&nbsp;also&nbsp;maintain&nbsp;a&nbsp;route,&nbsp;which&nbsp;defines&nbsp;what&nbsp;roads&nbsp;they&nbsp;want&nbsp;to&nbsp;travel&nbsp;on&nbsp;in&nbsp;the&nbsp;road&nbsp;network.<br>
Besides&nbsp;their&nbsp;actual&nbsp;lc&nbsp;model,&nbsp;Vehicles&nbsp;also&nbsp;handle&nbsp;any&nbsp;additional&nbsp;components&nbsp;of&nbsp;lane&nbsp;changing,<br>
such&nbsp;as&nbsp;relaxation,&nbsp;cooperation,&nbsp;or&nbsp;tactical&nbsp;lane&nbsp;changing&nbsp;models.<br>
Lastly,&nbsp;the&nbsp;vehicle&nbsp;class&nbsp;has&nbsp;some&nbsp;methods&nbsp;which&nbsp;may&nbsp;be&nbsp;used&nbsp;for&nbsp;certain&nbsp;boundary&nbsp;conditions.<br>
&nbsp;<br>
Attributes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehid:&nbsp;unique&nbsp;vehicle&nbsp;ID&nbsp;for&nbsp;hashing<br>
&nbsp;&nbsp;&nbsp;&nbsp;len:&nbsp;length&nbsp;of&nbsp;vehicle&nbsp;(float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;lane:&nbsp;<a href="#Lane">Lane</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;vehicle&nbsp;is&nbsp;currently&nbsp;on<br>
&nbsp;&nbsp;&nbsp;&nbsp;road:&nbsp;str&nbsp;name&nbsp;of&nbsp;the&nbsp;road&nbsp;lane&nbsp;belongs&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;cf_parameters:&nbsp;list&nbsp;of&nbsp;float&nbsp;parameters&nbsp;for&nbsp;the&nbsp;cf&nbsp;model<br>
&nbsp;&nbsp;&nbsp;&nbsp;lc_parameters:&nbsp;list&nbsp;of&nbsp;float&nbsp;parameters&nbsp;for&nbsp;the&nbsp;lc&nbsp;model<br>
&nbsp;&nbsp;&nbsp;&nbsp;relax_parameters:&nbsp;float&nbsp;parameter&nbsp;for&nbsp;relaxation;&nbsp;if&nbsp;None,&nbsp;no&nbsp;relaxation<br>
&nbsp;&nbsp;&nbsp;&nbsp;in_relax:&nbsp;bool,&nbsp;True&nbsp;if&nbsp;there&nbsp;is&nbsp;currently&nbsp;relaxation<br>
&nbsp;&nbsp;&nbsp;&nbsp;relax:&nbsp;if&nbsp;there&nbsp;is&nbsp;currently&nbsp;relaxation,&nbsp;relax&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;floats&nbsp;giving&nbsp;the&nbsp;relaxation&nbsp;values.<br>
&nbsp;&nbsp;&nbsp;&nbsp;relax_start:&nbsp;time&nbsp;index&nbsp;corresponding&nbsp;to&nbsp;relax[0]&nbsp;if&nbsp;in_relax,&nbsp;otherwise&nbsp;None.&nbsp;(int)<br>
&nbsp;&nbsp;&nbsp;&nbsp;route_parameters:&nbsp;parameters&nbsp;for&nbsp;the&nbsp;route&nbsp;model&nbsp;(list&nbsp;of&nbsp;floats)<br>
&nbsp;&nbsp;&nbsp;&nbsp;route:&nbsp;list&nbsp;of&nbsp;road&nbsp;names&nbsp;(str).&nbsp;When&nbsp;the&nbsp;vehicle&nbsp;first&nbsp;enters&nbsp;the&nbsp;simulation&nbsp;or&nbsp;enters&nbsp;a&nbsp;new&nbsp;road,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;route&nbsp;gets&nbsp;pop().<br>
&nbsp;&nbsp;&nbsp;&nbsp;routemem:&nbsp;route&nbsp;which&nbsp;was&nbsp;used&nbsp;to&nbsp;init&nbsp;vehicle.<br>
&nbsp;&nbsp;&nbsp;&nbsp;minacc:&nbsp;minimum&nbsp;allowed&nbsp;acceleration&nbsp;(float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;maxacc:&nbsp;maxmimum&nbsp;allowed&nbsp;acceleration(float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;maxspeed:&nbsp;maximum&nbsp;allowed&nbsp;speed&nbsp;(float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;hdbounds:&nbsp;tuple&nbsp;of&nbsp;minimum&nbsp;and&nbsp;maximum&nbsp;possible&nbsp;headway.<br>
&nbsp;&nbsp;&nbsp;&nbsp;eql_type:&nbsp;If&nbsp;'v',&nbsp;the&nbsp;vehicle's&nbsp;eqlfun&nbsp;accepts&nbsp;a&nbsp;speed&nbsp;and&nbsp;returns&nbsp;a&nbsp;headway.&nbsp;Otherwise&nbsp;it<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accepts&nbsp;a&nbsp;headway&nbsp;and&nbsp;returns&nbsp;a&nbsp;speed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;shift_parameters:&nbsp;list&nbsp;of&nbsp;float&nbsp;parameters&nbsp;for&nbsp;the&nbsp;tactical/cooperative&nbsp;model.&nbsp;shift_parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control&nbsp;how&nbsp;a&nbsp;vehicle&nbsp;can&nbsp;modify&nbsp;its&nbsp;acceleration&nbsp;in&nbsp;order&nbsp;to&nbsp;facilitate&nbsp;lane&nbsp;changing.<br>
&nbsp;&nbsp;&nbsp;&nbsp;coop_parameters:&nbsp;float&nbsp;between&nbsp;(0,&nbsp;1)&nbsp;which&nbsp;gives&nbsp;the&nbsp;base&nbsp;probability&nbsp;of&nbsp;the&nbsp;vehicle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cooperating&nbsp;with&nbsp;a&nbsp;vehicle&nbsp;wanting&nbsp;to&nbsp;change&nbsp;lanes<br>
&nbsp;&nbsp;&nbsp;&nbsp;lc_side:&nbsp;if&nbsp;the&nbsp;vehicle&nbsp;enters&nbsp;into&nbsp;a&nbsp;tactical&nbsp;or&nbsp;cooperative&nbsp;state,&nbsp;lc_side&nbsp;gives&nbsp;which&nbsp;side&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vehicle&nbsp;wants&nbsp;to&nbsp;change&nbsp;in.<br>
&nbsp;&nbsp;&nbsp;&nbsp;lc_urgency:&nbsp;for&nbsp;mandatory&nbsp;lane&nbsp;changes,&nbsp;lc_urgency&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;floats&nbsp;which&nbsp;control&nbsp;if<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;ego&nbsp;vehicle&nbsp;can&nbsp;force&nbsp;cooperation&nbsp;(simulating&nbsp;aggressive&nbsp;behavior)<br>
&nbsp;&nbsp;&nbsp;&nbsp;coop_veh:&nbsp;For&nbsp;cooperation,&nbsp;coop_veh&nbsp;is&nbsp;a&nbsp;reference&nbsp;the&nbsp;vehicle&nbsp;giving&nbsp;cooperation.&nbsp;There&nbsp;is&nbsp;no<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attribute&nbsp;(currently)&nbsp;which&nbsp;allows&nbsp;the&nbsp;ego&nbsp;vehicle&nbsp;to&nbsp;see&nbsp;if&nbsp;itself&nbsp;is&nbsp;giving&nbsp;cooperation.<br>
&nbsp;&nbsp;&nbsp;&nbsp;lead:&nbsp;leading&nbsp;vehicle&nbsp;(<a href="#Vehicle">Vehicle</a>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;fol:&nbsp;following&nbsp;vehicle&nbsp;(<a href="#Vehicle">Vehicle</a>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;lfol:&nbsp;left&nbsp;follower&nbsp;(<a href="#Vehicle">Vehicle</a>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;rfol:&nbsp;right&nbsp;follower&nbsp;(<a href="#Vehicle">Vehicle</a>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;llead:&nbsp;set&nbsp;of&nbsp;all&nbsp;vehicles&nbsp;which&nbsp;have&nbsp;the&nbsp;ego&nbsp;vehicle&nbsp;as&nbsp;a&nbsp;right&nbsp;follower<br>
&nbsp;&nbsp;&nbsp;&nbsp;rlead:&nbsp;set&nbsp;of&nbsp;all&nbsp;vehicles&nbsp;which&nbsp;have&nbsp;the&nbsp;ego&nbsp;vehicle&nbsp;as&nbsp;a&nbsp;left&nbsp;follower<br>
&nbsp;&nbsp;&nbsp;&nbsp;inittime:&nbsp;first&nbsp;time&nbsp;index&nbsp;a&nbsp;vehicle&nbsp;is&nbsp;simulated.<br>
&nbsp;&nbsp;&nbsp;&nbsp;endtime:&nbsp;the&nbsp;last&nbsp;time&nbsp;index&nbsp;a&nbsp;vehicle&nbsp;is&nbsp;simulated.&nbsp;(or&nbsp;None)<br>
&nbsp;&nbsp;&nbsp;&nbsp;leadmem:&nbsp;list&nbsp;of&nbsp;tuples,&nbsp;where&nbsp;each&nbsp;tuple&nbsp;is&nbsp;(lead&nbsp;vehicle,&nbsp;time)&nbsp;giving&nbsp;the&nbsp;time&nbsp;the&nbsp;ego&nbsp;vehicle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;begins&nbsp;to&nbsp;follow&nbsp;the&nbsp;lead&nbsp;vehicle.<br>
&nbsp;&nbsp;&nbsp;&nbsp;lanemem:&nbsp;list&nbsp;of&nbsp;tuples,&nbsp;where&nbsp;each&nbsp;tuple&nbsp;is&nbsp;(<a href="#Lane">Lane</a>,&nbsp;time)&nbsp;giving&nbsp;the&nbsp;time&nbsp;the&nbsp;ego&nbsp;vehicle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;enters&nbsp;the&nbsp;<a href="#Lane">Lane</a>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;posmem:&nbsp;list&nbsp;of&nbsp;floats&nbsp;giving&nbsp;the&nbsp;position,&nbsp;where&nbsp;the&nbsp;0&nbsp;index&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;position&nbsp;at&nbsp;inittime<br>
&nbsp;&nbsp;&nbsp;&nbsp;speedmem:&nbsp;list&nbsp;of&nbsp;floats&nbsp;giving&nbsp;the&nbsp;speed,&nbsp;where&nbsp;the&nbsp;0&nbsp;index&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;speed&nbsp;at&nbsp;inittime<br>
&nbsp;&nbsp;&nbsp;&nbsp;relaxmem:&nbsp;list&nbsp;of&nbsp;tuples&nbsp;where&nbsp;each&nbsp;tuple&nbsp;is&nbsp;(first&nbsp;time,&nbsp;last&nbsp;time,&nbsp;relaxation)&nbsp;where&nbsp;relaxation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gives&nbsp;the&nbsp;relaxation&nbsp;values&nbsp;for&nbsp;between&nbsp;first&nbsp;time&nbsp;and&nbsp;last&nbsp;time<br>
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;position&nbsp;(float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;speed:&nbsp;speed&nbsp;(float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;hd:&nbsp;headway&nbsp;(float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;acc:&nbsp;acceleration&nbsp;(float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;llane:&nbsp;the&nbsp;<a href="#Lane">Lane</a>&nbsp;to&nbsp;the&nbsp;left&nbsp;of&nbsp;the&nbsp;current&nbsp;lane&nbsp;the&nbsp;vehicle&nbsp;is&nbsp;on,&nbsp;or&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;rlane:&nbsp;the&nbsp;<a href="#Lane">Lane</a>&nbsp;to&nbsp;the&nbsp;right&nbsp;of&nbsp;the&nbsp;current&nbsp;lane&nbsp;the&nbsp;vehicle&nbsp;is&nbsp;on,&nbsp;or&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;l_lc:&nbsp;the&nbsp;current&nbsp;lane&nbsp;changing&nbsp;state&nbsp;for&nbsp;the&nbsp;left&nbsp;side,&nbsp;None,&nbsp;'discretionary'&nbsp;or&nbsp;'mandatory'<br>
&nbsp;&nbsp;&nbsp;&nbsp;r_lc:&nbsp;the&nbsp;current&nbsp;lane&nbsp;changing&nbsp;state&nbsp;for&nbsp;the&nbsp;right&nbsp;side,&nbsp;None,&nbsp;'discretionary'&nbsp;or&nbsp;'mandatory'<br>
&nbsp;&nbsp;&nbsp;&nbsp;cur_route:&nbsp;dictionary&nbsp;where&nbsp;keys&nbsp;are&nbsp;lanes,&nbsp;value&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;route&nbsp;event&nbsp;dictionaries&nbsp;which<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defines&nbsp;the&nbsp;route&nbsp;a&nbsp;vehicle&nbsp;with&nbsp;parameters&nbsp;p&nbsp;needs&nbsp;to&nbsp;take&nbsp;on&nbsp;that&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;route_events:&nbsp;list&nbsp;of&nbsp;current&nbsp;route&nbsp;events&nbsp;for&nbsp;current&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;lane_events:&nbsp;list&nbsp;of&nbsp;lane&nbsp;events&nbsp;for&nbsp;current&nbsp;lane<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Vehicle-__eq__"><strong>__eq__</strong></a>(self, other)</dt><dd><tt>Used&nbsp;for&nbsp;comparing&nbsp;two&nbsp;vehicles&nbsp;with&nbsp;==.</tt></dd></dl>

<dl><dt><a name="Vehicle-__hash__"><strong>__hash__</strong></a>(self)</dt><dd><tt>Vehicles&nbsp;need&nbsp;to&nbsp;be&nbsp;hashable.&nbsp;We&nbsp;hash&nbsp;them&nbsp;with&nbsp;a&nbsp;unique&nbsp;vehicle&nbsp;ID.</tt></dd></dl>

<dl><dt><a name="Vehicle-__init__"><strong>__init__</strong></a>(self, vehid, curlane, cf_parameters, lc_parameters, lead=None, fol=None, lfol=None, rfol=None, llead=None, rlead=None, length=3, eql_type='v', relax_parameters=12, shift_parameters=None, coop_parameters=0.2, route_parameters=None, route=None, accbounds=None, maxspeed=10000.0, hdbounds=None)</dt><dd><tt>Inits&nbsp;<a href="#Vehicle">Vehicle</a>.&nbsp;Cannot&nbsp;be&nbsp;used&nbsp;for&nbsp;simulation&nbsp;until&nbsp;initialize&nbsp;is&nbsp;also&nbsp;called.<br>
&nbsp;<br>
After&nbsp;a&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;is&nbsp;created,&nbsp;it&nbsp;is&nbsp;not&nbsp;immediatley&nbsp;added&nbsp;to&nbsp;simulation.&nbsp;This&nbsp;is&nbsp;because&nbsp;different<br>
upstream&nbsp;(inflow)&nbsp;boundary&nbsp;conditions&nbsp;may&nbsp;require&nbsp;to&nbsp;have&nbsp;access&nbsp;to&nbsp;the&nbsp;vehicle's&nbsp;parameters<br>
and&nbsp;methods&nbsp;before&nbsp;actually&nbsp;adding&nbsp;the&nbsp;vehicle.&nbsp;Thus,&nbsp;to&nbsp;use&nbsp;a&nbsp;vehicle&nbsp;you&nbsp;need&nbsp;to&nbsp;first&nbsp;call<br>
initialize,&nbsp;which&nbsp;sets&nbsp;the&nbsp;remaining&nbsp;attributes.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehid:&nbsp;unique&nbsp;vehicle&nbsp;ID&nbsp;for&nbsp;hashing<br>
&nbsp;&nbsp;&nbsp;&nbsp;curlane:&nbsp;lane&nbsp;vehicle&nbsp;starts&nbsp;on<br>
&nbsp;&nbsp;&nbsp;&nbsp;cf_parameters:&nbsp;list&nbsp;of&nbsp;float&nbsp;parameters&nbsp;for&nbsp;the&nbsp;cf&nbsp;model<br>
&nbsp;&nbsp;&nbsp;&nbsp;lc_parameters:&nbsp;list&nbsp;of&nbsp;float&nbsp;parameters&nbsp;for&nbsp;the&nbsp;lc&nbsp;model<br>
&nbsp;&nbsp;&nbsp;&nbsp;lead:&nbsp;leading&nbsp;vehicle&nbsp;(<a href="#Vehicle">Vehicle</a>).&nbsp;Optional,&nbsp;can&nbsp;be&nbsp;set&nbsp;by&nbsp;the&nbsp;boundary&nbsp;condition.<br>
&nbsp;&nbsp;&nbsp;&nbsp;fol:&nbsp;following&nbsp;vehicle&nbsp;(<a href="#Vehicle">Vehicle</a>).&nbsp;Optional,&nbsp;can&nbsp;be&nbsp;set&nbsp;by&nbsp;the&nbsp;boundary&nbsp;condition.<br>
&nbsp;&nbsp;&nbsp;&nbsp;lfol:&nbsp;left&nbsp;follower&nbsp;(<a href="#Vehicle">Vehicle</a>).&nbsp;Optional,&nbsp;can&nbsp;be&nbsp;set&nbsp;by&nbsp;the&nbsp;boundary&nbsp;condition.<br>
&nbsp;&nbsp;&nbsp;&nbsp;rfol:&nbsp;right&nbsp;follower&nbsp;(<a href="#Vehicle">Vehicle</a>).&nbsp;Optional,&nbsp;can&nbsp;be&nbsp;set&nbsp;by&nbsp;the&nbsp;boundary&nbsp;condition.<br>
&nbsp;&nbsp;&nbsp;&nbsp;llead:&nbsp;set&nbsp;of&nbsp;all&nbsp;vehicles&nbsp;which&nbsp;have&nbsp;the&nbsp;ego&nbsp;vehicle&nbsp;as&nbsp;a&nbsp;right&nbsp;follower.&nbsp;Optional,&nbsp;can&nbsp;be&nbsp;set<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;the&nbsp;boundary&nbsp;condition.<br>
&nbsp;&nbsp;&nbsp;&nbsp;rlead:&nbsp;set&nbsp;of&nbsp;all&nbsp;vehicles&nbsp;which&nbsp;have&nbsp;the&nbsp;ego&nbsp;vehicle&nbsp;as&nbsp;a&nbsp;left&nbsp;follower.&nbsp;Optional,&nbsp;can&nbsp;be&nbsp;set<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;the&nbsp;boundary&nbsp;condition.<br>
&nbsp;&nbsp;&nbsp;&nbsp;length:&nbsp;float&nbsp;(optional).&nbsp;length&nbsp;of&nbsp;vehicle.<br>
&nbsp;&nbsp;&nbsp;&nbsp;eql_type:&nbsp;If&nbsp;'v',&nbsp;the&nbsp;vehicle's&nbsp;eqlfun&nbsp;accepts&nbsp;a&nbsp;speed&nbsp;and&nbsp;returns&nbsp;a&nbsp;headway.&nbsp;Otherwise&nbsp;it<br>
&nbsp;&nbsp;&nbsp;&nbsp;accepts&nbsp;a&nbsp;headway&nbsp;and&nbsp;returns&nbsp;a&nbsp;speed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;relax_parameters:&nbsp;float&nbsp;parameter&nbsp;for&nbsp;relaxation;&nbsp;if&nbsp;None,&nbsp;no&nbsp;relaxation<br>
&nbsp;&nbsp;&nbsp;&nbsp;shift_parameters:&nbsp;list&nbsp;of&nbsp;float&nbsp;parameters&nbsp;for&nbsp;the&nbsp;tactical/cooperative&nbsp;model.&nbsp;shift_parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control&nbsp;how&nbsp;a&nbsp;vehicle&nbsp;can&nbsp;modify&nbsp;its&nbsp;acceleration&nbsp;in&nbsp;order&nbsp;to&nbsp;facilitate&nbsp;lane&nbsp;changing.<br>
&nbsp;&nbsp;&nbsp;&nbsp;coop_parameters:&nbsp;float&nbsp;between&nbsp;(0,&nbsp;1)&nbsp;which&nbsp;gives&nbsp;the&nbsp;base&nbsp;probability&nbsp;of&nbsp;the&nbsp;vehicle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cooperating&nbsp;with&nbsp;a&nbsp;vehicle&nbsp;wanting&nbsp;to&nbsp;change&nbsp;lanes<br>
&nbsp;&nbsp;&nbsp;&nbsp;route:&nbsp;list&nbsp;of&nbsp;road&nbsp;names&nbsp;(str)&nbsp;which&nbsp;defines&nbsp;the&nbsp;route&nbsp;for&nbsp;the&nbsp;vehicle.<br>
&nbsp;&nbsp;&nbsp;&nbsp;route_parameters:&nbsp;parameters&nbsp;for&nbsp;the&nbsp;route&nbsp;model&nbsp;(list&nbsp;of&nbsp;floats).<br>
&nbsp;&nbsp;&nbsp;&nbsp;accbounds:&nbsp;tuple&nbsp;of&nbsp;bounds&nbsp;for&nbsp;acceleration.<br>
&nbsp;&nbsp;&nbsp;&nbsp;maxspeed:&nbsp;maximum&nbsp;allowed&nbsp;speed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;hdbounds:&nbsp;tuple&nbsp;of&nbsp;bounds&nbsp;for&nbsp;headway.</tt></dd></dl>

<dl><dt><a name="Vehicle-__ne__"><strong>__ne__</strong></a>(self, other)</dt><dd><tt>Used&nbsp;for&nbsp;comparing&nbsp;two&nbsp;vehicles&nbsp;with&nbsp;!=.</tt></dd></dl>

<dl><dt><a name="Vehicle-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Display&nbsp;for&nbsp;vehicle&nbsp;in&nbsp;interactive&nbsp;console.</tt></dd></dl>

<dl><dt><a name="Vehicle-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Convert&nbsp;vehicle&nbsp;to&nbsp;a&nbsp;str&nbsp;representation.</tt></dd></dl>

<dl><dt><a name="Vehicle-cf_model"><strong>cf_model</strong></a>(self, p, state)</dt><dd><tt>Defines&nbsp;car&nbsp;following&nbsp;model.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;p:&nbsp;parameters&nbsp;for&nbsp;model&nbsp;(cf_parameters)<br>
&nbsp;&nbsp;&nbsp;&nbsp;state:&nbsp;list&nbsp;of&nbsp;headway,&nbsp;speed,&nbsp;leader&nbsp;speed<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;acceleration&nbsp;of&nbsp;the&nbsp;model.</tt></dd></dl>

<dl><dt><a name="Vehicle-eqlfun"><strong>eqlfun</strong></a>(self, p, v)</dt><dd><tt>Equilibrium&nbsp;function.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;p:.&nbsp;car&nbsp;following&nbsp;parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;v:&nbsp;velocity/speed<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;s:&nbsp;headway&nbsp;such&nbsp;that&nbsp;(v,s)&nbsp;is&nbsp;an&nbsp;equilibrium&nbsp;solution&nbsp;for&nbsp;parameters&nbsp;p</tt></dd></dl>

<dl><dt><a name="Vehicle-free_cf"><strong>free_cf</strong></a>(self, p, spd)</dt><dd><tt>Defines&nbsp;car&nbsp;following&nbsp;model&nbsp;in&nbsp;free&nbsp;flow.<br>
&nbsp;<br>
The&nbsp;free&nbsp;flow&nbsp;model&nbsp;can&nbsp;be&nbsp;obtained&nbsp;simply&nbsp;by&nbsp;letting&nbsp;the&nbsp;headway&nbsp;go&nbsp;to&nbsp;infinity&nbsp;for&nbsp;cf_model.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;p:&nbsp;parameters&nbsp;for&nbsp;model&nbsp;(cf_parameters)<br>
&nbsp;&nbsp;&nbsp;&nbsp;spd:&nbsp;speed&nbsp;(float)<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;acceleration&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;car&nbsp;following&nbsp;model&nbsp;in&nbsp;free&nbsp;flow.</tt></dd></dl>

<dl><dt><a name="Vehicle-get_cf"><strong>get_cf</strong></a>(self, hd, spd, lead, curlane, timeind, dt, userelax)</dt><dd><tt>Wrapper&nbsp;for&nbsp;cf_model.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;hd&nbsp;(TYPE):&nbsp;headway<br>
&nbsp;&nbsp;&nbsp;&nbsp;spd&nbsp;(TYPE):&nbsp;speed<br>
&nbsp;&nbsp;&nbsp;&nbsp;lead&nbsp;(TYPE):&nbsp;lead&nbsp;<a href="#Vehicle">Vehicle</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;curlane&nbsp;(TYPE):&nbsp;lane&nbsp;self&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;is&nbsp;on<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind&nbsp;(TYPE):&nbsp;time&nbsp;index<br>
&nbsp;&nbsp;&nbsp;&nbsp;dt&nbsp;(TYPE):&nbsp;timestep<br>
&nbsp;&nbsp;&nbsp;&nbsp;userelax&nbsp;(TYPE):&nbsp;boolean&nbsp;for&nbsp;relaxation<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;acc&nbsp;(TYPE):&nbsp;DESCRIPTION.</tt></dd></dl>

<dl><dt><a name="Vehicle-get_eql"><strong>get_eql</strong></a>(self, x, input_type='v')</dt><dd><tt>Get&nbsp;equilibrium&nbsp;using&nbsp;provided&nbsp;function&nbsp;eqlfun,&nbsp;possibly&nbsp;inverting&nbsp;it&nbsp;if&nbsp;necessary.</tt></dd></dl>

<dl><dt><a name="Vehicle-get_flow"><strong>get_flow</strong></a>(self, x, leadlen=None, input_type='v')</dt><dd><tt>Input&nbsp;a&nbsp;speed&nbsp;or&nbsp;headway,&nbsp;and&nbsp;output&nbsp;the&nbsp;flow&nbsp;based&nbsp;on&nbsp;the&nbsp;equilibrium&nbsp;solution.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;x:&nbsp;Input,&nbsp;either&nbsp;headway&nbsp;or&nbsp;speed<br>
&nbsp;&nbsp;&nbsp;&nbsp;leadlen:&nbsp;When&nbsp;converting&nbsp;an&nbsp;equilibrium&nbsp;solution&nbsp;to&nbsp;a&nbsp;flow,&nbsp;we&nbsp;must&nbsp;use&nbsp;a&nbsp;vehicle&nbsp;length.&nbsp;leadlen<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;that&nbsp;vehicle&nbsp;length.&nbsp;If&nbsp;None,&nbsp;we&nbsp;will&nbsp;infer&nbsp;the&nbsp;vehicle&nbsp;length.<br>
&nbsp;&nbsp;&nbsp;&nbsp;input_type:&nbsp;if&nbsp;input_type&nbsp;is&nbsp;'v'&nbsp;(v&nbsp;for&nbsp;velocity),&nbsp;then&nbsp;x&nbsp;is&nbsp;a&nbsp;speed.&nbsp;Otherwise&nbsp;x&nbsp;is&nbsp;a&nbsp;headway.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;x&nbsp;is&nbsp;a&nbsp;speed,&nbsp;we&nbsp;return&nbsp;a&nbsp;headway.&nbsp;Otherwise&nbsp;we&nbsp;return&nbsp;a&nbsp;speed.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;TYPE:&nbsp;DESCRIPTION.</tt></dd></dl>

<dl><dt><a name="Vehicle-initialize"><strong>initialize</strong></a>(self, pos, spd, hd, inittime)</dt><dd><tt>Sets&nbsp;the&nbsp;remaining&nbsp;attributes&nbsp;of&nbsp;the&nbsp;vehicle,&nbsp;making&nbsp;it&nbsp;able&nbsp;to&nbsp;be&nbsp;simulated.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;position&nbsp;at&nbsp;inittime<br>
&nbsp;&nbsp;&nbsp;&nbsp;spd:&nbsp;speed&nbsp;at&nbsp;inittime<br>
&nbsp;&nbsp;&nbsp;&nbsp;hd:&nbsp;headway&nbsp;at&nbsp;inittime<br>
&nbsp;&nbsp;&nbsp;&nbsp;inittime:&nbsp;first&nbsp;time&nbsp;index&nbsp;vehicle&nbsp;is&nbsp;simulated<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.</tt></dd></dl>

<dl><dt><a name="Vehicle-inv_flow"><strong>inv_flow</strong></a>(self, x, leadlen=None, output_type='v', congested=True)</dt><dd><tt>Get&nbsp;equilibrium&nbsp;solution&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;provided&nbsp;flow.</tt></dd></dl>

<dl><dt><a name="Vehicle-set_cf"><strong>set_cf</strong></a>(self, timeind, dt)</dt><dd><tt>Sets&nbsp;a&nbsp;vehicle's&nbsp;acceleration&nbsp;by&nbsp;calling&nbsp;get_cf.</tt></dd></dl>

<dl><dt><a name="Vehicle-set_lc"><strong>set_lc</strong></a>(self, lc_actions, timeind, dt)</dt><dd><tt>Evaluates&nbsp;a&nbsp;vehicle's&nbsp;lane&nbsp;changing&nbsp;model,&nbsp;recording&nbsp;the&nbsp;result&nbsp;in&nbsp;lc_actions.<br>
&nbsp;<br>
The&nbsp;result&nbsp;of&nbsp;the&nbsp;lane&nbsp;changing&nbsp;(lc)&nbsp;model&nbsp;can&nbsp;be&nbsp;either&nbsp;'l'&nbsp;or&nbsp;'r'&nbsp;for&nbsp;left/right&nbsp;respectively,<br>
or&nbsp;None,&nbsp;in&nbsp;which&nbsp;case&nbsp;there&nbsp;is&nbsp;no&nbsp;lane&nbsp;change.&nbsp;If&nbsp;the&nbsp;model&nbsp;has&nbsp;tactical/cooperative&nbsp;elements&nbsp;added,<br>
calling&nbsp;the&nbsp;lc&nbsp;model&nbsp;may&nbsp;cause&nbsp;some&nbsp;vehicles&nbsp;to&nbsp;enter&nbsp;into&nbsp;a&nbsp;tactical&nbsp;or&nbsp;cooperative&nbsp;state,&nbsp;which<br>
modifies&nbsp;the&nbsp;vehicle's&nbsp;acceleration&nbsp;by&nbsp;using&nbsp;the&nbsp;shift_eql&nbsp;method.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;lc_actions:&nbsp;dictionary&nbsp;where&nbsp;keys&nbsp;are&nbsp;Vehicles&nbsp;which&nbsp;changed&nbsp;lanes,&nbsp;values&nbsp;are&nbsp;the&nbsp;side&nbsp;of&nbsp;change<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind:&nbsp;time&nbsp;index<br>
&nbsp;&nbsp;&nbsp;&nbsp;dt:&nbsp;timestep<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.&nbsp;(Modifies&nbsp;lc_actions,&nbsp;some&nbsp;vehicle&nbsp;attributes,&nbsp;in&nbsp;place)</tt></dd></dl>

<dl><dt><a name="Vehicle-shift_eql"><strong>shift_eql</strong></a>(self, p, v, shift_parameters, state)</dt><dd><tt>Model&nbsp;used&nbsp;for&nbsp;applying&nbsp;tactical/cooperative&nbsp;acceleration&nbsp;during&nbsp;lane&nbsp;changes.<br>
&nbsp;<br>
The&nbsp;model&nbsp;works&nbsp;by&nbsp;solving&nbsp;for&nbsp;an&nbsp;acceleration&nbsp;which&nbsp;modifies&nbsp;the&nbsp;equilibrium&nbsp;solution&nbsp;by&nbsp;some<br>
fixed&nbsp;amount.&nbsp;Any&nbsp;model&nbsp;which&nbsp;has&nbsp;an&nbsp;equilibrium&nbsp;solution&nbsp;which&nbsp;can&nbsp;be&nbsp;solved&nbsp;analytically,<br>
it&nbsp;should&nbsp;be&nbsp;possible&nbsp;to&nbsp;define&nbsp;a&nbsp;model&nbsp;in&nbsp;this&nbsp;way.&nbsp;For&nbsp;IDM,&nbsp;the&nbsp;result&nbsp;that&nbsp;comes&nbsp;out&nbsp;lets<br>
you&nbsp;modify&nbsp;the&nbsp;equilibrium&nbsp;by&nbsp;a&nbsp;multiple.<br>
E.g.&nbsp;if&nbsp;the&nbsp;shift&nbsp;parameter&nbsp;=&nbsp;.5,&nbsp;and&nbsp;the&nbsp;equilibrium&nbsp;headway&nbsp;is&nbsp;usually&nbsp;20&nbsp;at&nbsp;the&nbsp;provided&nbsp;speed,<br>
we&nbsp;return&nbsp;an&nbsp;acceleration&nbsp;which&nbsp;makes&nbsp;the&nbsp;equilibrium&nbsp;headway&nbsp;10.&nbsp;If&nbsp;we&nbsp;request&nbsp;'decel',&nbsp;the&nbsp;parameter<br>
must&nbsp;be&nbsp;&gt;&nbsp;1&nbsp;so&nbsp;that&nbsp;the&nbsp;acceleration&nbsp;is&nbsp;negative.&nbsp;Otherwise&nbsp;the&nbsp;parameter&nbsp;must&nbsp;be&nbsp;&lt;&nbsp;1.<br>
&nbsp;<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;p:&nbsp;car&nbsp;following&nbsp;parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;v:&nbsp;speed<br>
&nbsp;&nbsp;&nbsp;&nbsp;shift_parameters:&nbsp;list&nbsp;of&nbsp;deceleration,&nbsp;acceleration&nbsp;parameters.&nbsp;eq'l&nbsp;at&nbsp;v&nbsp;goes&nbsp;to&nbsp;n<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;times&nbsp;of&nbsp;normal,&nbsp;where&nbsp;n&nbsp;is&nbsp;the&nbsp;parameter<br>
&nbsp;&nbsp;&nbsp;&nbsp;state:&nbsp;if&nbsp;state&nbsp;=&nbsp;'decel'&nbsp;we&nbsp;use&nbsp;shift_parameters[0]&nbsp;else&nbsp;shift_parameters[1]<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;TYPE:&nbsp;float&nbsp;acceleration</tt></dd></dl>

<dl><dt><a name="Vehicle-update"><strong>update</strong></a>(self, timeind, dt)</dt><dd><tt>Applies&nbsp;bounds&nbsp;and&nbsp;updates&nbsp;a&nbsp;vehicle&nbsp;longitudinal&nbsp;state/memory.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-connect_helper"><strong>connect_helper</strong></a>(connect, pos)</dt><dd><tt>Helper&nbsp;function&nbsp;takes&nbsp;in&nbsp;connect_left/right&nbsp;attribute,&nbsp;position,&nbsp;and&nbsp;returns&nbsp;the&nbsp;correct&nbsp;connection.</tt></dd></dl>
 <dl><dt><a name="-downstream_wrapper"><strong>downstream_wrapper</strong></a>(method='speed', time_series=None, congested=True, merge_side='l', merge_anchor_ind=None, target_lane=None, self_lane=None, shift=1, minacc=-2)</dt><dd><tt>Defines&nbsp;call_downstream&nbsp;method&nbsp;for&nbsp;<a href="#Lane">Lane</a>.&nbsp;keyword&nbsp;options&nbsp;control&nbsp;behavior&nbsp;of&nbsp;call_downstream.<br>
&nbsp;<br>
call_downstream&nbsp;is&nbsp;used&nbsp;instead&nbsp;of&nbsp;the&nbsp;cf&nbsp;model&nbsp;in&nbsp;order&nbsp;to&nbsp;get&nbsp;the&nbsp;acceleration&nbsp;in&nbsp;cases&nbsp;where&nbsp;there&nbsp;is<br>
no&nbsp;lead&nbsp;vehicle&nbsp;(e.g.&nbsp;because&nbsp;the&nbsp;lead&nbsp;vehicle&nbsp;has&nbsp;left&nbsp;the&nbsp;simulation).&nbsp;Essentially,&nbsp;call_downstream<br>
will&nbsp;determine&nbsp;the&nbsp;rate&nbsp;at&nbsp;which&nbsp;vehicles&nbsp;can&nbsp;exit&nbsp;the&nbsp;simulation.<br>
call_downstream&nbsp;also&nbsp;gets&nbsp;used&nbsp;for&nbsp;on-ramps/merges&nbsp;where&nbsp;you&nbsp;have&nbsp;no&nbsp;leader&nbsp;not&nbsp;because&nbsp;you&nbsp;are<br>
leaving&nbsp;the&nbsp;simulation,&nbsp;but&nbsp;rather&nbsp;because&nbsp;the&nbsp;lane&nbsp;is&nbsp;about&nbsp;to&nbsp;end&nbsp;and&nbsp;you&nbsp;need&nbsp;to&nbsp;move&nbsp;over.<br>
Lastly,&nbsp;if&nbsp;the&nbsp;simulation&nbsp;starts&nbsp;with&nbsp;no&nbsp;Vehicles,&nbsp;call_downstream&nbsp;will&nbsp;entirely&nbsp;determine<br>
The&nbsp;keyword&nbsp;arg&nbsp;'method'&nbsp;defines&nbsp;the&nbsp;behavior&nbsp;of&nbsp;call_downstream&nbsp;method&nbsp;for&nbsp;a&nbsp;<a href="#Lane">Lane</a>.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;method:&nbsp;one&nbsp;of&nbsp;'speed',&nbsp;'free',&nbsp;'flow',&nbsp;'free&nbsp;merge',&nbsp;'merge'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'speed'&nbsp;-&nbsp;Give&nbsp;a&nbsp;function&nbsp;which&nbsp;explicitly&nbsp;returns&nbsp;the&nbsp;speed,&nbsp;and&nbsp;we&nbsp;compute&nbsp;the&nbsp;acceleration.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_series:&nbsp;function&nbsp;takes&nbsp;in&nbsp;timeind,&nbsp;returns&nbsp;speed<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'free'&nbsp;-&nbsp;We&nbsp;use&nbsp;the&nbsp;vehicle's&nbsp;free_cf&nbsp;method&nbsp;to&nbsp;update&nbsp;the&nbsp;acceleration.&nbsp;This&nbsp;is&nbsp;as&nbsp;if&nbsp;vehicles<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can&nbsp;exit&nbsp;the&nbsp;simulation&nbsp;as&nbsp;quickly&nbsp;as&nbsp;possible.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'flow'&nbsp;-&nbsp;We&nbsp;get&nbsp;a&nbsp;flow&nbsp;from&nbsp;time_series;&nbsp;we&nbsp;then&nbsp;use&nbsp;the&nbsp;vehicle's&nbsp;inverse&nbsp;flow&nbsp;method&nbsp;to&nbsp;find<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;speed&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;flow<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_series:&nbsp;function&nbsp;takes&nbsp;in&nbsp;timeind,&nbsp;returns&nbsp;flow<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;congested:&nbsp;whether&nbsp;to&nbsp;assume&nbsp;flow&nbsp;is&nbsp;in&nbsp;congested&nbsp;or&nbsp;free&nbsp;flow&nbsp;branch<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'free&nbsp;merge'&nbsp;-&nbsp;We&nbsp;use&nbsp;the&nbsp;vehicle's&nbsp;free&nbsp;flow&nbsp;method&nbsp;to&nbsp;update,&nbsp;unless&nbsp;we&nbsp;are&nbsp;getting&nbsp;too&nbsp;close<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;road,&nbsp;in&nbsp;which&nbsp;case&nbsp;we&nbsp;ensure&nbsp;the&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;will&nbsp;stop&nbsp;before&nbsp;reaching&nbsp;the&nbsp;end&nbsp;of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;lane.&nbsp;We&nbsp;assume&nbsp;that&nbsp;vehicles&nbsp;stop&nbsp;as&nbsp;if&nbsp;there&nbsp;was&nbsp;a&nbsp;stationary&nbsp;lead&nbsp;vehicle&nbsp;at&nbsp;the&nbsp;end&nbsp;of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;lane.&nbsp;This&nbsp;is&nbsp;done&nbsp;by&nbsp;creating&nbsp;an&nbsp;<a href="#AnchorVehicle">AnchorVehicle</a>&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;lane&nbsp;which&nbsp;is&nbsp;used&nbsp;as&nbsp;a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lead&nbsp;vehicle.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minacc:&nbsp;We&nbsp;always&nbsp;compute&nbsp;the&nbsp;vehicle's&nbsp;acceleration&nbsp;using&nbsp;the&nbsp;anchor&nbsp;as&nbsp;a&nbsp;leader.&nbsp;If&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vehicle&nbsp;has&nbsp;an&nbsp;acceleration&nbsp;more&nbsp;negative&nbsp;than&nbsp;minacc,&nbsp;we&nbsp;use&nbsp;the&nbsp;anchor&nbsp;as&nbsp;a&nbsp;leader.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherwise,&nbsp;we&nbsp;use&nbsp;the&nbsp;vehicle's&nbsp;free&nbsp;flow&nbsp;method<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self_lane:&nbsp;vehicle&nbsp;needs&nbsp;to&nbsp;stop&nbsp;when&nbsp;reaching&nbsp;the&nbsp;end&nbsp;of&nbsp;self_lane<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'merge'&nbsp;-&nbsp;This&nbsp;is&nbsp;meant&nbsp;to&nbsp;give&nbsp;a&nbsp;longitudinal&nbsp;update&nbsp;in&nbsp;congested&nbsp;conditions&nbsp;while&nbsp;on&nbsp;a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bottleneck&nbsp;(on&nbsp;ramp&nbsp;or&nbsp;lane&nbsp;ending,&nbsp;where&nbsp;you&nbsp;must&nbsp;merge).&nbsp;minacc&nbsp;and&nbsp;self_lane&nbsp;give&nbsp;behavior<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;same&nbsp;as&nbsp;in&nbsp;'free&nbsp;merge'.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merge_side:&nbsp;either&nbsp;'l'&nbsp;or&nbsp;'r'&nbsp;depending&nbsp;on&nbsp;which&nbsp;side&nbsp;vehicles&nbsp;need&nbsp;to&nbsp;merge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target_lane:&nbsp;lanes&nbsp;vehicles&nbsp;need&nbsp;to&nbsp;merge&nbsp;into<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merge_anchor_ind:&nbsp;index&nbsp;for&nbsp;merge&nbsp;anchor&nbsp;in&nbsp;target_lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self_lane:&nbsp;if&nbsp;not&nbsp;None,&nbsp;the&nbsp;vehicle&nbsp;needs&nbsp;to&nbsp;stop&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;self_lane.&nbsp;If&nbsp;None,&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vehicle&nbsp;won't&nbsp;stop.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minacc:&nbsp;if&nbsp;the&nbsp;acceleration&nbsp;needed&nbsp;to&nbsp;stop&nbsp;is&nbsp;more&nbsp;negative&nbsp;than&nbsp;minacc,&nbsp;we&nbsp;begin&nbsp;to&nbsp;stop.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shift:&nbsp;we&nbsp;infer&nbsp;a&nbsp;speed&nbsp;based&nbsp;on&nbsp;conditions&nbsp;in&nbsp;target_lane.&nbsp;We&nbsp;do&nbsp;this&nbsp;by&nbsp;shifting&nbsp;the&nbsp;speed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;a&nbsp;vehicle&nbsp;in&nbsp;target_lane&nbsp;by&nbsp;shift.&nbsp;(e.g.&nbsp;shift&nbsp;=&nbsp;1,&nbsp;use&nbsp;the&nbsp;speed&nbsp;from&nbsp;1&nbsp;second&nbsp;ago)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_series:&nbsp;if&nbsp;we&nbsp;aren't&nbsp;stopping&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;self_lane,&nbsp;&nbsp;and&nbsp;can't&nbsp;find&nbsp;a&nbsp;vehicle&nbsp;to&nbsp;infer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;speed&nbsp;from,&nbsp;time_series&nbsp;controls&nbsp;the&nbsp;behavior.&nbsp;If&nbsp;None,&nbsp;the&nbsp;vehicle&nbsp;uses&nbsp;its&nbsp;free&nbsp;cf<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method.&nbsp;Otherwise,&nbsp;time_series&nbsp;specifies&nbsp;a&nbsp;speed&nbsp;which&nbsp;is&nbsp;used.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;call_downstream&nbsp;method&nbsp;for&nbsp;a&nbsp;<a href="#Lane">Lane</a>.&nbsp;Takes&nbsp;in&nbsp;(veh,&nbsp;timeind,&nbsp;dt)&nbsp;and&nbsp;returns&nbsp;acceleration.</tt></dd></dl>
 <dl><dt><a name="-eql_inflow_congested"><strong>eql_inflow_congested</strong></a>(curlane, inflow, c=0.8, check_gap=True)</dt><dd><tt>Extra&nbsp;condition&nbsp;when&nbsp;adding&nbsp;vehicles&nbsp;for&nbsp;use&nbsp;in&nbsp;congested&nbsp;conditions.&nbsp;Requires&nbsp;to&nbsp;invert&nbsp;flow.<br>
&nbsp;<br>
Suggested&nbsp;by&nbsp;Treiber,&nbsp;Kesting&nbsp;in&nbsp;their&nbsp;traffic&nbsp;flow&nbsp;book&nbsp;for&nbsp;congested&nbsp;conditions.&nbsp;Requires&nbsp;to&nbsp;invert<br>
the&nbsp;inflow&nbsp;to&nbsp;obtain&nbsp;the&nbsp;equilibrium&nbsp;headway.&nbsp;The&nbsp;actual&nbsp;headway&nbsp;on&nbsp;the&nbsp;road&nbsp;must&nbsp;be&nbsp;at&nbsp;least&nbsp;c&nbsp;times<br>
the&nbsp;equilibrium&nbsp;headway&nbsp;for&nbsp;the&nbsp;vehicle&nbsp;to&nbsp;be&nbsp;added,&nbsp;where&nbsp;c&nbsp;is&nbsp;a&nbsp;constant.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;curlane:&nbsp;<a href="#Lane">Lane</a>&nbsp;with&nbsp;upstream&nbsp;boundary&nbsp;condition,&nbsp;which&nbsp;will&nbsp;possibly&nbsp;have&nbsp;a&nbsp;vehicle&nbsp;added.<br>
&nbsp;&nbsp;&nbsp;&nbsp;inflow:&nbsp;current&nbsp;instantaneous&nbsp;flow.<br>
&nbsp;&nbsp;&nbsp;&nbsp;c:&nbsp;Constant,&nbsp;should&nbsp;be&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;1.&nbsp;Lower&nbsp;is&nbsp;less&nbsp;strict&nbsp;-&nbsp;Treiber,&nbsp;Kesting&nbsp;suggest&nbsp;.8<br>
&nbsp;&nbsp;&nbsp;&nbsp;check_gap:&nbsp;If&nbsp;False,&nbsp;we&nbsp;don't&nbsp;check&nbsp;the&nbsp;Treiber,&nbsp;Kesting&nbsp;condition,&nbsp;so&nbsp;we&nbsp;don't&nbsp;have&nbsp;to&nbsp;invert<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;flow.&nbsp;We&nbsp;always&nbsp;just&nbsp;add&nbsp;the&nbsp;vehicle<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;The&nbsp;vehicle&nbsp;is&nbsp;not&nbsp;to&nbsp;be&nbsp;added,&nbsp;we&nbsp;return&nbsp;None.&nbsp;Otherwise,&nbsp;we&nbsp;return&nbsp;the&nbsp;(pos,&nbsp;spd,&nbsp;hd)&nbsp;for&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehicle&nbsp;to&nbsp;be&nbsp;added&nbsp;with.</tt></dd></dl>
 <dl><dt><a name="-eql_inflow_free"><strong>eql_inflow_free</strong></a>(curlane, inflow)</dt><dd><tt>Suggested&nbsp;by&nbsp;Treiber,&nbsp;Kesting&nbsp;for&nbsp;free&nbsp;conditions.&nbsp;Requires&nbsp;to&nbsp;invert&nbsp;the&nbsp;inflow&nbsp;to&nbsp;obtain&nbsp;velocity.</tt></dd></dl>
 <dl><dt><a name="-get_eql_helper"><strong>get_eql_helper</strong></a>(veh, x, input_type='v', eql_type='v', spdbounds=(0, 10000.0), hdbounds=(0, 10000.0), tol=0.1)</dt><dd><tt>Solves&nbsp;for&nbsp;the&nbsp;equilibrium&nbsp;solution&nbsp;of&nbsp;vehicle&nbsp;veh&nbsp;given&nbsp;input&nbsp;x.<br>
&nbsp;<br>
To&nbsp;use&nbsp;this&nbsp;method,&nbsp;the&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;must&nbsp;have&nbsp;an&nbsp;eqlfun&nbsp;method&nbsp;defined.&nbsp;The&nbsp;eqlfun&nbsp;can&nbsp;typically&nbsp;be&nbsp;defined<br>
analyticallly&nbsp;for&nbsp;one&nbsp;input&nbsp;type.<br>
The&nbsp;equilibrium&nbsp;(eql)&nbsp;solution&nbsp;is&nbsp;defined&nbsp;as&nbsp;a&nbsp;pair&nbsp;of&nbsp;(headway,&nbsp;speed)&nbsp;such&nbsp;that&nbsp;the&nbsp;car&nbsp;following&nbsp;model<br>
will&nbsp;give&nbsp;0&nbsp;acceleration.&nbsp;For&nbsp;any&nbsp;possible&nbsp;speed,&nbsp;(0&nbsp;through&nbsp;maxspeed)&nbsp;there&nbsp;is&nbsp;a&nbsp;unique&nbsp;headway&nbsp;which<br>
defines&nbsp;the&nbsp;equilibrium&nbsp;solution.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;to&nbsp;obtain&nbsp;equilibrium&nbsp;solution&nbsp;for<br>
&nbsp;&nbsp;&nbsp;&nbsp;x:&nbsp;float&nbsp;of&nbsp;either&nbsp;speed&nbsp;or&nbsp;headway<br>
&nbsp;&nbsp;&nbsp;&nbsp;input_type:&nbsp;if&nbsp;input_type&nbsp;is&nbsp;'v'&nbsp;(v&nbsp;for&nbsp;velocity),&nbsp;then&nbsp;x&nbsp;is&nbsp;a&nbsp;speed.&nbsp;Otherwise&nbsp;x&nbsp;is&nbsp;a&nbsp;headway.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;x&nbsp;is&nbsp;a&nbsp;speed,&nbsp;we&nbsp;return&nbsp;a&nbsp;headway.&nbsp;Otherwise&nbsp;we&nbsp;return&nbsp;a&nbsp;speed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;eql_type:&nbsp;If&nbsp;'v',&nbsp;the&nbsp;vehicle's&nbsp;eqlfun&nbsp;accepts&nbsp;a&nbsp;speed&nbsp;and&nbsp;returns&nbsp;a&nbsp;headway.&nbsp;Otherwise&nbsp;it<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accepts&nbsp;a&nbsp;headway&nbsp;and&nbsp;returns&nbsp;a&nbsp;speed.&nbsp;If&nbsp;input_type&nbsp;!=&nbsp;eql_type,&nbsp;we&nbsp;numerically&nbsp;invert&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eqlfun.<br>
&nbsp;&nbsp;&nbsp;&nbsp;spdbounds:&nbsp;Bounds&nbsp;on&nbsp;speed.&nbsp;If&nbsp;x&nbsp;is&nbsp;outside&nbsp;the&nbsp;bounds,&nbsp;we&nbsp;project&nbsp;it&nbsp;onto&nbsp;bounds.&nbsp;Also&nbsp;used<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;eql_type&nbsp;!=&nbsp;input_type.<br>
&nbsp;&nbsp;&nbsp;&nbsp;hdbounds:&nbsp;Bounds&nbsp;on&nbsp;headway.&nbsp;If&nbsp;x&nbsp;is&nbsp;outside&nbsp;the&nbsp;bounds,&nbsp;we&nbsp;project&nbsp;it&nbsp;onto&nbsp;bounds.&nbsp;Also&nbsp;used<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;eql_type&nbsp;!=&nbsp;input_type.<br>
&nbsp;&nbsp;&nbsp;&nbsp;tol:&nbsp;tolerance&nbsp;for&nbsp;solver.<br>
&nbsp;<br>
Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;RuntimeError:&nbsp;If&nbsp;the&nbsp;solver&nbsp;cannot&nbsp;invert&nbsp;the&nbsp;equilibrium&nbsp;function,&nbsp;we&nbsp;return&nbsp;an&nbsp;error.&nbsp;If&nbsp;this<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;happens,&nbsp;it's&nbsp;very&nbsp;likely&nbsp;because&nbsp;your&nbsp;equilibrium&nbsp;function&nbsp;is&nbsp;wrong,&nbsp;or&nbsp;because&nbsp;your&nbsp;bounds<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;wrong.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;value&nbsp;of&nbsp;either&nbsp;headway&nbsp;or&nbsp;speed&nbsp;which&nbsp;together&nbsp;with&nbsp;input&nbsp;x&nbsp;defines&nbsp;the&nbsp;equilibrium&nbsp;solution.</tt></dd></dl>
 <dl><dt><a name="-get_guess"><strong>get_guess</strong></a>(lcfol, lclead, veh, lcsidefol, newlcsidelane)</dt><dd><tt>Generates&nbsp;a&nbsp;guess&nbsp;to&nbsp;use&nbsp;for&nbsp;finding&nbsp;the&nbsp;newlcside&nbsp;follower&nbsp;for&nbsp;a&nbsp;vehicle.<br>
&nbsp;<br>
Since&nbsp;we&nbsp;keep&nbsp;the&nbsp;lfol/rfol&nbsp;updated,&nbsp;after&nbsp;a&nbsp;lane&nbsp;change&nbsp;we&nbsp;need&nbsp;to&nbsp;find&nbsp;the&nbsp;newlcside&nbsp;follower&nbsp;if<br>
applicable.&nbsp;This&nbsp;function&nbsp;will&nbsp;generate&nbsp;a&nbsp;guess&nbsp;by&nbsp;using&nbsp;the&nbsp;lcside&nbsp;fol&nbsp;of&nbsp;the&nbsp;lcfol/lclead.<br>
If&nbsp;such&nbsp;a&nbsp;guess&nbsp;cannot&nbsp;be&nbsp;found,&nbsp;we&nbsp;use&nbsp;the&nbsp;<a href="#AnchorVehicle">AnchorVehicle</a>&nbsp;for&nbsp;the&nbsp;newlcside&nbsp;lane.<br>
&nbsp;<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;lcfol:&nbsp;lcfol&nbsp;for&nbsp;veh&nbsp;(fol&nbsp;after&nbsp;lane&nbsp;change)<br>
&nbsp;&nbsp;&nbsp;&nbsp;lclead:&nbsp;lclead&nbsp;for&nbsp;veh&nbsp;(lead&nbsp;after&nbsp;lane&nbsp;change)<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;want&nbsp;to&nbsp;generate&nbsp;a&nbsp;guess&nbsp;to&nbsp;find&nbsp;veh's&nbsp;new&nbsp;lcside&nbsp;follower.<br>
&nbsp;&nbsp;&nbsp;&nbsp;lcsidefol:&nbsp;str,&nbsp;either&nbsp;lfol&nbsp;if&nbsp;vehicle&nbsp;changes&nbsp;left&nbsp;or&nbsp;rfol&nbsp;otherwise.<br>
&nbsp;&nbsp;&nbsp;&nbsp;newlcsidelane:&nbsp;new&nbsp;lane&nbsp;change&nbsp;side&nbsp;lane&nbsp;after&nbsp;veh&nbsp;changes&nbsp;lanes.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;guess:&nbsp;<a href="#Vehicle">Vehicle</a>/<a href="#AnchorVehicle">AnchorVehicle</a>&nbsp;to&nbsp;use&nbsp;as&nbsp;guess&nbsp;for&nbsp;leadfol_find</tt></dd></dl>
 <dl><dt><a name="-get_inflow_wrapper"><strong>get_inflow_wrapper</strong></a>(time_series, inflow_type='flow')</dt><dd><tt>Defines&nbsp;get_inflow&nbsp;method&nbsp;for&nbsp;<a href="#Lane">Lane</a>.<br>
&nbsp;<br>
get_inflow&nbsp;is&nbsp;used&nbsp;for&nbsp;a&nbsp;lane&nbsp;with&nbsp;upstream&nbsp;boundary&nbsp;conditions&nbsp;to&nbsp;increment&nbsp;the&nbsp;inflow_buffer<br>
attribute&nbsp;which&nbsp;controls&nbsp;when&nbsp;we&nbsp;attempt&nbsp;to&nbsp;add&nbsp;vehicles&nbsp;to&nbsp;the&nbsp;simulation.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;time_series:&nbsp;function&nbsp;which&nbsp;takes&nbsp;in&nbsp;a&nbsp;timeind&nbsp;and&nbsp;returns&nbsp;either&nbsp;a&nbsp;flow&nbsp;(inflow_type&nbsp;=&nbsp;'flow')&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speed&nbsp;(inflow_type&nbsp;=&nbsp;'speed'&nbsp;or&nbsp;'congested').<br>
&nbsp;&nbsp;&nbsp;&nbsp;inflow_type:&nbsp;Method&nbsp;to&nbsp;add&nbsp;vehicles.&nbsp;One&nbsp;of&nbsp;'flow',&nbsp;'speed',&nbsp;'congested'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'flow'&nbsp;-&nbsp;time_series&nbsp;returns&nbsp;the&nbsp;flow&nbsp;explicitly<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'speed'&nbsp;-&nbsp;time_series&nbsp;returns&nbsp;a&nbsp;speed,&nbsp;we&nbsp;get&nbsp;a&nbsp;flow&nbsp;from&nbsp;the&nbsp;speed&nbsp;using&nbsp;the&nbsp;get_eql&nbsp;method&nbsp;of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;<a href="#Vehicle">Vehicle</a>.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'congested'&nbsp;-&nbsp;This&nbsp;is&nbsp;meant&nbsp;to&nbsp;add&nbsp;a&nbsp;vehicle&nbsp;with&nbsp;~0&nbsp;acceleration&nbsp;as&nbsp;soon&nbsp;as&nbsp;it&nbsp;is&nbsp;possible&nbsp;to&nbsp;do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;so.&nbsp;This&nbsp;is&nbsp;similar&nbsp;to&nbsp;'speed',&nbsp;but&nbsp;instead&nbsp;of&nbsp;getting&nbsp;speed&nbsp;from&nbsp;time_series,&nbsp;we&nbsp;get&nbsp;it&nbsp;from<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;anchor's&nbsp;lead&nbsp;vehicle.&nbsp;This&nbsp;may&nbsp;help&nbsp;remove&nbsp;artifacts&nbsp;from&nbsp;the&nbsp;upstream&nbsp;boundary<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;condition&nbsp;caused&nbsp;by&nbsp;simulations&nbsp;with&nbsp;different&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;parameters.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requires&nbsp;get_eql&nbsp;method&nbsp;of&nbsp;the&nbsp;<a href="#Vehicle">Vehicle</a>.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;get_inflow&nbsp;method&nbsp;for&nbsp;a&nbsp;<a href="#Lane">Lane</a>.&nbsp;Takes&nbsp;in&nbsp;(timeind)&nbsp;and&nbsp;returns&nbsp;instantaneous&nbsp;flow,&nbsp;vehicle&nbsp;speed,<br>
&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;that&nbsp;time.&nbsp;If&nbsp;we&nbsp;return&nbsp;None&nbsp;for&nbsp;the&nbsp;speed,&nbsp;increment_inflow&nbsp;will&nbsp;invert&nbsp;the&nbsp;flow&nbsp;to&nbsp;obtain&nbsp;speed.</tt></dd></dl>
 <dl><dt><a name="-get_new_hd"><strong>get_new_hd</strong></a>(lcsidefol, veh, lcsidelane)</dt><dd><tt>Calculates&nbsp;new&nbsp;headways&nbsp;for&nbsp;a&nbsp;vehicle&nbsp;and&nbsp;its&nbsp;left&nbsp;or&nbsp;right&nbsp;follower.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;lcsidefol:&nbsp;either&nbsp;the&nbsp;lfol&nbsp;or&nbsp;rfol&nbsp;of&nbsp;veh.<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;whose&nbsp;lane&nbsp;changing&nbsp;model&nbsp;is&nbsp;being&nbsp;evaluated<br>
&nbsp;&nbsp;&nbsp;&nbsp;lcsidelane:&nbsp;the&nbsp;lcside&nbsp;lane&nbsp;of&nbsp;veh.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;newlcsidefolhd:&nbsp;new&nbsp;float&nbsp;headway&nbsp;for&nbsp;lcsidefol<br>
&nbsp;&nbsp;&nbsp;&nbsp;newlcsidehd:&nbsp;new&nbsp;float&nbsp;headway&nbsp;for&nbsp;veh</tt></dd></dl>
 <dl><dt><a name="-increment_inflow_wrapper"><strong>increment_inflow_wrapper</strong></a>(method='ceql', speed_series=None, accel_bound=-2, check_gap=True, shift=1, c=0.8)</dt><dd><tt>Defines&nbsp;increment_inflow&nbsp;method&nbsp;for&nbsp;<a href="#Lane">Lane</a>.&nbsp;keyword&nbsp;args&nbsp;control&nbsp;behavior&nbsp;of&nbsp;increment_inflow.<br>
&nbsp;<br>
The&nbsp;increment_inflow&nbsp;method&nbsp;has&nbsp;two&nbsp;parts&nbsp;to&nbsp;it.&nbsp;First,&nbsp;it&nbsp;is&nbsp;responsible&nbsp;for&nbsp;determining&nbsp;when&nbsp;to&nbsp;add<br>
vehicles&nbsp;to&nbsp;the&nbsp;simulation.&nbsp;It&nbsp;does&nbsp;this&nbsp;by&nbsp;updating&nbsp;an&nbsp;attribute&nbsp;inflow_buffer.&nbsp;When&nbsp;inflow_buffer&nbsp;&gt;=&nbsp;1,<br>
it&nbsp;attempts&nbsp;to&nbsp;add&nbsp;a&nbsp;vehicle&nbsp;to&nbsp;the&nbsp;simulation.&nbsp;There&nbsp;are&nbsp;extra&nbsp;conditions&nbsp;required&nbsp;to&nbsp;add&nbsp;a&nbsp;vehicle,<br>
which&nbsp;are&nbsp;controlled&nbsp;by&nbsp;the&nbsp;'method'&nbsp;keyword&nbsp;arg.<br>
Once&nbsp;it&nbsp;has&nbsp;been&nbsp;determined&nbsp;a&nbsp;new&nbsp;vehicle&nbsp;can&nbsp;be&nbsp;added,&nbsp;this&nbsp;function&nbsp;is&nbsp;also&nbsp;responsible&nbsp;for&nbsp;calling<br>
the&nbsp;initialize&nbsp;method&nbsp;of&nbsp;the&nbsp;new&nbsp;vehicle,&nbsp;adding&nbsp;the&nbsp;new&nbsp;vehicle&nbsp;with&nbsp;a&nbsp;correct&nbsp;leader/follower<br>
relationships,&nbsp;and&nbsp;also&nbsp;inits&nbsp;the&nbsp;next&nbsp;vehicle&nbsp;which&nbsp;is&nbsp;to&nbsp;be&nbsp;added.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;method:&nbsp;One&nbsp;of&nbsp;'ceql'&nbsp;(eql_inflow_congested),&nbsp;'feql'&nbsp;(eql_inflow_free),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'shifted'&nbsp;(shifted_speed_inflow),&nbsp;or&nbsp;'speed'&nbsp;(speed_inflow)&nbsp;-&nbsp;refer&nbsp;to&nbsp;those&nbsp;functions<br>
&nbsp;&nbsp;&nbsp;&nbsp;speed_series:&nbsp;for&nbsp;speed_inflow&nbsp;method<br>
&nbsp;&nbsp;&nbsp;&nbsp;accel_bound:&nbsp;for&nbsp;speed_inflow&nbsp;and&nbsp;shifted_speed_inflow&nbsp;methods<br>
&nbsp;&nbsp;&nbsp;&nbsp;check_gap:&nbsp;for&nbsp;eql_inflow_congested&nbsp;method<br>
&nbsp;&nbsp;&nbsp;&nbsp;shift:&nbsp;for&nbsp;shifted_speed_inflow&nbsp;method<br>
&nbsp;&nbsp;&nbsp;&nbsp;c:&nbsp;for&nbsp;eql_inflow_congested&nbsp;method<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;increment_inflow&nbsp;method&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vehicles:&nbsp;set&nbsp;of&nbsp;vehicles<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vehid:&nbsp;vehicle&nbsp;ID&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;next&nbsp;created&nbsp;vehicle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeind:&nbsp;time&nbsp;index<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dt:&nbsp;timestep<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None.&nbsp;Modifies&nbsp;vehicles,&nbsp;Lanes&nbsp;in&nbsp;place.</tt></dd></dl>
 <dl><dt><a name="-inv_flow_helper"><strong>inv_flow_helper</strong></a>(veh, x, leadlen=None, output_type='v', congested=True, eql_type='v', spdbounds=(0, 10000.0), hdbounds=(0, 10000.0), tol=0.1, ftol=0.01)</dt><dd><tt>Solves&nbsp;for&nbsp;the&nbsp;equilibrium&nbsp;solution&nbsp;corresponding&nbsp;to&nbsp;a&nbsp;given&nbsp;flow&nbsp;x.<br>
&nbsp;<br>
To&nbsp;use&nbsp;this&nbsp;method,&nbsp;a&nbsp;vehicle&nbsp;must&nbsp;have&nbsp;an&nbsp;eqlfun&nbsp;defined.&nbsp;A&nbsp;equilibrium&nbsp;solution&nbsp;can&nbsp;be&nbsp;converted&nbsp;to<br>
a&nbsp;flow.&nbsp;This&nbsp;function&nbsp;takes&nbsp;a&nbsp;flow&nbsp;and&nbsp;finds&nbsp;the&nbsp;corresponding&nbsp;equilibrium&nbsp;solution.&nbsp;To&nbsp;do&nbsp;this,<br>
it&nbsp;first&nbsp;finds&nbsp;the&nbsp;maximum&nbsp;flow&nbsp;possible,&nbsp;and&nbsp;then&nbsp;based&nbsp;on&nbsp;whether&nbsp;the&nbsp;flow&nbsp;corresponds&nbsp;to&nbsp;the<br>
congested&nbsp;or&nbsp;free&nbsp;flow&nbsp;regime,&nbsp;we&nbsp;solve&nbsp;for&nbsp;the&nbsp;correct&nbsp;equilibrium.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;to&nbsp;invert&nbsp;flow&nbsp;for.<br>
&nbsp;&nbsp;&nbsp;&nbsp;x:&nbsp;flow&nbsp;(float)&nbsp;to&nbsp;invert<br>
&nbsp;&nbsp;&nbsp;&nbsp;leadlen:&nbsp;When&nbsp;converting&nbsp;an&nbsp;equilibrium&nbsp;solution&nbsp;to&nbsp;a&nbsp;flow,&nbsp;we&nbsp;must&nbsp;use&nbsp;a&nbsp;vehicle&nbsp;length.&nbsp;leadlen<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;that&nbsp;vehicle&nbsp;length.&nbsp;If&nbsp;None,&nbsp;we&nbsp;will&nbsp;infer&nbsp;the&nbsp;vehicle&nbsp;length.<br>
&nbsp;&nbsp;&nbsp;&nbsp;output_type:&nbsp;if&nbsp;'v',&nbsp;we&nbsp;want&nbsp;to&nbsp;return&nbsp;a&nbsp;velocity,&nbsp;if&nbsp;'s'&nbsp;we&nbsp;want&nbsp;to&nbsp;return&nbsp;a&nbsp;'headway'.&nbsp;If&nbsp;'both',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we&nbsp;want&nbsp;to&nbsp;return&nbsp;a&nbsp;tuple.<br>
&nbsp;&nbsp;&nbsp;&nbsp;congested:&nbsp;True&nbsp;if&nbsp;we&nbsp;assume&nbsp;the&nbsp;given&nbsp;flow&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;congested&nbsp;regime,&nbsp;otherwise<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we&nbsp;assume&nbsp;it&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;free&nbsp;flow&nbsp;regime.<br>
&nbsp;&nbsp;&nbsp;&nbsp;eql_type:&nbsp;If&nbsp;'v',&nbsp;the&nbsp;vehicle's&nbsp;eqlfun&nbsp;accepts&nbsp;a&nbsp;speed&nbsp;and&nbsp;returns&nbsp;a&nbsp;headway.&nbsp;Otherwise&nbsp;it<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accepts&nbsp;a&nbsp;headway&nbsp;and&nbsp;returns&nbsp;a&nbsp;speed.&nbsp;If&nbsp;input_type&nbsp;!=&nbsp;eql_type,&nbsp;we&nbsp;numerically&nbsp;invert&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eqlfun.<br>
&nbsp;&nbsp;&nbsp;&nbsp;spdbounds:&nbsp;Bounds&nbsp;on&nbsp;speed.&nbsp;If&nbsp;x&nbsp;is&nbsp;outside&nbsp;the&nbsp;bounds,&nbsp;we&nbsp;project&nbsp;it&nbsp;onto&nbsp;bounds.&nbsp;Also&nbsp;used<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;eql_type&nbsp;!=&nbsp;input_type.<br>
&nbsp;&nbsp;&nbsp;&nbsp;hdbounds:&nbsp;Bounds&nbsp;on&nbsp;headway.&nbsp;If&nbsp;x&nbsp;is&nbsp;outside&nbsp;the&nbsp;bounds,&nbsp;we&nbsp;project&nbsp;it&nbsp;onto&nbsp;bounds.&nbsp;Also&nbsp;used<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;eql_type&nbsp;!=&nbsp;input_type.<br>
&nbsp;&nbsp;&nbsp;&nbsp;tol:&nbsp;tolerance&nbsp;for&nbsp;solver.<br>
&nbsp;&nbsp;&nbsp;&nbsp;ftol:&nbsp;tolerance&nbsp;for&nbsp;solver&nbsp;for&nbsp;finding&nbsp;maximum&nbsp;flow.<br>
&nbsp;<br>
Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;RuntimeError:&nbsp;Raised&nbsp;if&nbsp;either&nbsp;solver&nbsp;fails.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;velocity&nbsp;if&nbsp;output_type&nbsp;=&nbsp;'v',&nbsp;float&nbsp;headway&nbsp;if&nbsp;output_type&nbsp;=&nbsp;'s',&nbsp;tuple&nbsp;of&nbsp;(velocity,&nbsp;headway)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;output_type&nbsp;=&nbsp;'both'</tt></dd></dl>
 <dl><dt><a name="-make_cur_route"><strong>make_cur_route</strong></a>(p, curlane, nextroadname)</dt><dd><tt>Creates&nbsp;cur_route&nbsp;attribute&nbsp;(stores&nbsp;route&nbsp;events)&nbsp;for&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;after&nbsp;entering&nbsp;a&nbsp;new&nbsp;lane.<br>
&nbsp;<br>
Refer&nbsp;to&nbsp;update_route&nbsp;for&nbsp;a&nbsp;description&nbsp;of&nbsp;route&nbsp;events.<br>
Upon&nbsp;entering&nbsp;a&nbsp;new&nbsp;road,&nbsp;we&nbsp;create&nbsp;a&nbsp;cur_route&nbsp;which&nbsp;stores&nbsp;the&nbsp;list&nbsp;of&nbsp;route&nbsp;events&nbsp;for&nbsp;several&nbsp;lanes,<br>
specifically&nbsp;the&nbsp;lanes&nbsp;we&nbsp;will&nbsp;ultimately&nbsp;end&nbsp;up&nbsp;on,&nbsp;as&nbsp;well&nbsp;as&nbsp;all&nbsp;lanes&nbsp;which&nbsp;we&nbsp;will&nbsp;need&nbsp;to&nbsp;cross<br>
to&nbsp;reach&nbsp;those&nbsp;lanes&nbsp;we&nbsp;want&nbsp;to&nbsp;be&nbsp;on.&nbsp;We&nbsp;do&nbsp;not&nbsp;create&nbsp;the&nbsp;routes&nbsp;for&nbsp;every&nbsp;single&nbsp;lane&nbsp;on&nbsp;a&nbsp;road.<br>
Roads&nbsp;have&nbsp;a&nbsp;'connect&nbsp;to'&nbsp;key&nbsp;whose&nbsp;value&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of:<br>
&nbsp;&nbsp;&nbsp;&nbsp;pos:&nbsp;for&nbsp;'continue'&nbsp;change_type,&nbsp;a&nbsp;float&nbsp;which&nbsp;gives&nbsp;the&nbsp;position&nbsp;that&nbsp;the&nbsp;current&nbsp;road<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changes&nbsp;to&nbsp;the&nbsp;desired&nbsp;road.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;'merge'&nbsp;type,&nbsp;a&nbsp;tuple&nbsp;of&nbsp;the&nbsp;first&nbsp;position&nbsp;that&nbsp;changing&nbsp;into&nbsp;the&nbsp;desired&nbsp;road<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;becomes&nbsp;possible,&nbsp;and&nbsp;the&nbsp;last&nbsp;position&nbsp;where&nbsp;it&nbsp;is&nbsp;still&nbsp;possible&nbsp;to&nbsp;change&nbsp;into&nbsp;that&nbsp;road.<br>
&nbsp;&nbsp;&nbsp;&nbsp;change_type:&nbsp;if&nbsp;'continue',&nbsp;this&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;case&nbsp;where&nbsp;the&nbsp;current&nbsp;road&nbsp;turns&nbsp;into<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;next&nbsp;road&nbsp;in&nbsp;the&nbsp;route;&nbsp;the&nbsp;vehicle&nbsp;still&nbsp;needs&nbsp;to&nbsp;make&nbsp;sure&nbsp;it&nbsp;is&nbsp;in&nbsp;the&nbsp;right&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(different&nbsp;lanes&nbsp;may&nbsp;transition&nbsp;to&nbsp;different&nbsp;roads)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;'merge',&nbsp;this&nbsp;is&nbsp;the&nbsp;situation&nbsp;where&nbsp;the&nbsp;vehicle&nbsp;needs&nbsp;to&nbsp;change&nbsp;lanes&nbsp;onto&nbsp;a&nbsp;different&nbsp;road.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thus&nbsp;in&nbsp;the&nbsp;'merge'&nbsp;case&nbsp;after&nbsp;completing&nbsp;its&nbsp;lane&nbsp;change,&nbsp;the&nbsp;vehicle&nbsp;is&nbsp;on&nbsp;the&nbsp;next&nbsp;desired<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;road,&nbsp;in&nbsp;contrast&nbsp;to&nbsp;the&nbsp;continue&nbsp;case&nbsp;where&nbsp;the&nbsp;vehicle&nbsp;actually&nbsp;needs&nbsp;to&nbsp;reach&nbsp;the&nbsp;end&nbsp;of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;lane&nbsp;in&nbsp;order&nbsp;to&nbsp;transition.<br>
&nbsp;&nbsp;&nbsp;&nbsp;laneind:&nbsp;if&nbsp;'continue',&nbsp;a&nbsp;tuple&nbsp;of&nbsp;2&nbsp;ints,&nbsp;giving&nbsp;the&nbsp;leftmost&nbsp;and&nbsp;rightmost&nbsp;lanes&nbsp;which&nbsp;will<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue&nbsp;to&nbsp;the&nbsp;desired&nbsp;lane.&nbsp;if&nbsp;'merge',&nbsp;the&nbsp;laneind&nbsp;of&nbsp;the&nbsp;lane&nbsp;we&nbsp;need&nbsp;to&nbsp;be&nbsp;on&nbsp;to&nbsp;merge.<br>
&nbsp;&nbsp;&nbsp;&nbsp;str:&nbsp;for&nbsp;'merge'&nbsp;type&nbsp;only,&nbsp;gives&nbsp;whether&nbsp;we&nbsp;want&nbsp;to&nbsp;do&nbsp;a&nbsp;left&nbsp;or&nbsp;right&nbsp;change&nbsp;upon&nbsp;reaching<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;laneind<br>
&nbsp;&nbsp;&nbsp;&nbsp;nextroad:&nbsp;desired&nbsp;road<br>
&nbsp;<br>
Explanation&nbsp;of&nbsp;current&nbsp;route&nbsp;model&nbsp;-<br>
suppose&nbsp;you&nbsp;need&nbsp;to&nbsp;be&nbsp;in&nbsp;lane&nbsp;'2'&nbsp;by&nbsp;position&nbsp;'x'&nbsp;and&nbsp;start&nbsp;in&nbsp;lane&nbsp;'1',&nbsp;then&nbsp;starting:<br>
&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;x&nbsp;-&nbsp;2*p[0]&nbsp;-&nbsp;2*p[1]&nbsp;you&nbsp;will&nbsp;end&nbsp;discretionary&nbsp;changing&nbsp;into&nbsp;lane&nbsp;'0'<br>
&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;x&nbsp;-&nbsp;p[0]&nbsp;-&nbsp;p[1]&nbsp;you&nbsp;wil&nbsp;begin&nbsp;mandatory&nbsp;changing&nbsp;into&nbsp;lane&nbsp;'2'<br>
&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;x&nbsp;-&nbsp;p[0]&nbsp;your&nbsp;mandatory&nbsp;change&nbsp;will&nbsp;have&nbsp;urgency&nbsp;of&nbsp;100%&nbsp;which&nbsp;will&nbsp;always&nbsp;force<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cooperation&nbsp;of&nbsp;your&nbsp;l/rfol&nbsp;(assuming&nbsp;you&nbsp;have&nbsp;cooperation&nbsp;added&nbsp;to&nbsp;your&nbsp;lc&nbsp;model)<br>
for&nbsp;lane&nbsp;changing&nbsp;with&nbsp;a&nbsp;merge/diverse&nbsp;(e.g.&nbsp;on/off-ramp)&nbsp;which&nbsp;begins&nbsp;at&nbsp;'x'&nbsp;and&nbsp;ends&nbsp;at&nbsp;'y',<br>
you&nbsp;will&nbsp;start&nbsp;mandatory&nbsp;at&nbsp;'x'&nbsp;always,&nbsp;reaching&nbsp;100%&nbsp;cooperation&nbsp;by&nbsp;'y'&nbsp;-&nbsp;p[0]<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;p:&nbsp;parameters,&nbsp;length&nbsp;2&nbsp;list&nbsp;of&nbsp;floats,&nbsp;where&nbsp;p[0]&nbsp;is&nbsp;a&nbsp;safety&nbsp;buffer&nbsp;for&nbsp;merging&nbsp;and&nbsp;p[1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;a&nbsp;comfortable&nbsp;distance&nbsp;for&nbsp;merging<br>
&nbsp;&nbsp;&nbsp;&nbsp;curlane:&nbsp;<a href="#Lane">Lane</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;create&nbsp;route&nbsp;events&nbsp;for<br>
&nbsp;&nbsp;&nbsp;&nbsp;nextroadname:&nbsp;str&nbsp;name&nbsp;of&nbsp;the&nbsp;next&nbsp;road&nbsp;in&nbsp;the&nbsp;route&nbsp;(the&nbsp;next&nbsp;road&nbsp;you&nbsp;want&nbsp;to&nbsp;be&nbsp;on&nbsp;after&nbsp;leaving<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curlane's&nbsp;road)<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;cur_route:&nbsp;dictionary&nbsp;where&nbsp;keys&nbsp;are&nbsp;lanes,&nbsp;value&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;route&nbsp;event&nbsp;dictionaries&nbsp;which<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defines&nbsp;the&nbsp;route&nbsp;a&nbsp;vehicle&nbsp;with&nbsp;parameters&nbsp;p&nbsp;needs&nbsp;to&nbsp;take&nbsp;on&nbsp;that&nbsp;lane</tt></dd></dl>
 <dl><dt><a name="-make_route_helper"><strong>make_route_helper</strong></a>(p, cur_route, curroad, curlaneind, laneind, curpos)</dt><dd><tt>Generates&nbsp;list&nbsp;of&nbsp;route&nbsp;events&nbsp;for&nbsp;all&nbsp;lanes&nbsp;with&nbsp;indexes&nbsp;[curlaneind,&nbsp;laneind).<br>
&nbsp;<br>
Starting&nbsp;on&nbsp;curroad&nbsp;in&nbsp;lane&nbsp;with&nbsp;index&nbsp;curlaneind,&nbsp;wanting&nbsp;to&nbsp;be&nbsp;in&nbsp;lane&nbsp;index&nbsp;laneind&nbsp;by&nbsp;position&nbsp;curpos,<br>
generates&nbsp;route&nbsp;events&nbsp;for&nbsp;all&nbsp;lanes&nbsp;in&nbsp;[curlaneind,&nbsp;laneind).&nbsp;If&nbsp;curlaneind&nbsp;&lt;&nbsp;laneind,&nbsp;starts&nbsp;at<br>
laneind&nbsp;-1,&nbsp;moving&nbsp;to&nbsp;the&nbsp;left&nbsp;until&nbsp;routes&nbsp;on&nbsp;all&nbsp;lanes&nbsp;are&nbsp;defined.&nbsp;Similarly&nbsp;for&nbsp;curlaneind&nbsp;&gt;&nbsp;laneind.<br>
Assumes&nbsp;we&nbsp;already&nbsp;have&nbsp;the&nbsp;route&nbsp;for&nbsp;laneind&nbsp;in&nbsp;cur_route.<br>
Edge&nbsp;cases&nbsp;where&nbsp;routes&nbsp;have&nbsp;different&nbsp;lengths&nbsp;are&nbsp;handled.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;p:&nbsp;parameters,&nbsp;length&nbsp;2&nbsp;list&nbsp;of&nbsp;floats,&nbsp;where&nbsp;p[0]&nbsp;is&nbsp;a&nbsp;safety&nbsp;buffer&nbsp;for&nbsp;merging&nbsp;and&nbsp;p[1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;a&nbsp;comfortable&nbsp;distance&nbsp;for&nbsp;merging<br>
&nbsp;&nbsp;&nbsp;&nbsp;cur_route:&nbsp;dictionary&nbsp;where&nbsp;keys&nbsp;are&nbsp;lanes,&nbsp;value&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;route&nbsp;event&nbsp;dictionaries&nbsp;which<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defines&nbsp;the&nbsp;route&nbsp;a&nbsp;vehicle&nbsp;with&nbsp;parameters&nbsp;p&nbsp;needs&nbsp;to&nbsp;take&nbsp;on&nbsp;that&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;curroad:&nbsp;road&nbsp;that&nbsp;the&nbsp;route&nbsp;is&nbsp;being&nbsp;generated&nbsp;for<br>
&nbsp;&nbsp;&nbsp;&nbsp;curlaneind:&nbsp;index&nbsp;of&nbsp;the&nbsp;lane&nbsp;that&nbsp;the&nbsp;vehicle&nbsp;starts&nbsp;in<br>
&nbsp;&nbsp;&nbsp;&nbsp;laneind:&nbsp;index&nbsp;of&nbsp;the&nbsp;lane&nbsp;that&nbsp;we&nbsp;want&nbsp;to&nbsp;be&nbsp;in&nbsp;by&nbsp;position&nbsp;curpos<br>
&nbsp;&nbsp;&nbsp;&nbsp;curpos:&nbsp;we&nbsp;want&nbsp;to&nbsp;be&nbsp;in&nbsp;lane&nbsp;with&nbsp;index&nbsp;laneind&nbsp;by&nbsp;curpos<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;cur_route:&nbsp;Updates&nbsp;cur_route&nbsp;in&nbsp;place</tt></dd></dl>
 <dl><dt><a name="-new_relaxation"><strong>new_relaxation</strong></a>(veh, timeind, dt)</dt><dd><tt>Generates&nbsp;relaxation&nbsp;for&nbsp;a&nbsp;vehicle&nbsp;after&nbsp;it&nbsp;experiences&nbsp;a&nbsp;lane&nbsp;change.<br>
&nbsp;<br>
This&nbsp;is&nbsp;called&nbsp;directly&nbsp;after&nbsp;a&nbsp;vehicle&nbsp;changes&nbsp;it&nbsp;lane,&nbsp;while&nbsp;it&nbsp;still&nbsp;has&nbsp;the&nbsp;old&nbsp;value&nbsp;for&nbsp;its<br>
headway,&nbsp;and&nbsp;its&nbsp;position&nbsp;has&nbsp;not&nbsp;yet&nbsp;been&nbsp;updated.<br>
See&nbsp;(https://arxiv.org/abs/1904.08395)&nbsp;for&nbsp;an&nbsp;explanation&nbsp;of&nbsp;the&nbsp;relaxation&nbsp;model.<br>
This&nbsp;implements&nbsp;single&nbsp;parameter&nbsp;relaxation.&nbsp;The&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;attributes&nbsp;associated&nbsp;with&nbsp;relaxation&nbsp;are<br>
&nbsp;&nbsp;&nbsp;&nbsp;relax_parameters:&nbsp;float&nbsp;which&nbsp;gives&nbsp;the&nbsp;relaxation&nbsp;constant&nbsp;(units&nbsp;of&nbsp;time)<br>
&nbsp;&nbsp;&nbsp;&nbsp;in_relax:&nbsp;bool&nbsp;of&nbsp;whether&nbsp;or&nbsp;not&nbsp;vehicle&nbsp;is&nbsp;experiencing&nbsp;relaxation&nbsp;currently<br>
&nbsp;&nbsp;&nbsp;&nbsp;relax:&nbsp;list&nbsp;of&nbsp;floats&nbsp;which&nbsp;stores&nbsp;the&nbsp;relaxation&nbsp;values<br>
&nbsp;&nbsp;&nbsp;&nbsp;relax_start:&nbsp;time&nbsp;index&nbsp;(timeind)&nbsp;of&nbsp;the&nbsp;0&nbsp;index&nbsp;of&nbsp;relax<br>
&nbsp;&nbsp;&nbsp;&nbsp;relaxmem:&nbsp;memory&nbsp;of&nbsp;past&nbsp;relaxation,&nbsp;list&nbsp;of&nbsp;tuples&nbsp;of&nbsp;(starttime,&nbsp;endtime,&nbsp;relax)<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;to&nbsp;add&nbsp;relaxation&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind:&nbsp;int&nbsp;giving&nbsp;the&nbsp;timestep&nbsp;of&nbsp;the&nbsp;simulation&nbsp;(0&nbsp;indexed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;dt:&nbsp;float&nbsp;of&nbsp;time&nbsp;unit&nbsp;that&nbsp;passes&nbsp;in&nbsp;each&nbsp;timestep<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;relaxation&nbsp;attributes&nbsp;for&nbsp;vehicle&nbsp;in&nbsp;place.</tt></dd></dl>
 <dl><dt><a name="-set_lane_events"><strong>set_lane_events</strong></a>(veh)</dt><dd><tt>Creates&nbsp;lane_events&nbsp;attribute&nbsp;for&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;after&nbsp;entering&nbsp;a&nbsp;new&nbsp;lane.<br>
&nbsp;<br>
Refer&nbsp;to&nbsp;update_lane_events&nbsp;for&nbsp;description&nbsp;of&nbsp;lane&nbsp;events.&nbsp;Note&nbsp;that&nbsp;we&nbsp;only&nbsp;need&nbsp;to&nbsp;add&nbsp;upcoming<br>
lane&nbsp;events,&nbsp;and&nbsp;past&nbsp;lane&nbsp;events&nbsp;are&nbsp;not&nbsp;applied&nbsp;(this&nbsp;is&nbsp;in&nbsp;contrast&nbsp;to&nbsp;route_events,&nbsp;where&nbsp;past<br>
events&nbsp;ARE&nbsp;applied.)<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;to&nbsp;be&nbsp;updated<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;veh&nbsp;in&nbsp;place.</tt></dd></dl>
 <dl><dt><a name="-set_lc_helper"><strong>set_lc_helper</strong></a>(veh, chk_lc=1, get_fol=True)</dt><dd><tt>Calculates&nbsp;the&nbsp;new&nbsp;headways&nbsp;to&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;lane&nbsp;changing&nbsp;(LC)&nbsp;model.<br>
&nbsp;<br>
Evaluates&nbsp;the&nbsp;lane&nbsp;changing&nbsp;situation&nbsp;to&nbsp;decide&nbsp;if&nbsp;we&nbsp;need&nbsp;to&nbsp;evaluate&nbsp;lane&nbsp;changing&nbsp;model&nbsp;on&nbsp;the<br>
left&nbsp;side,&nbsp;right&nbsp;side,&nbsp;both&nbsp;sides,&nbsp;or&nbsp;neither.&nbsp;For&nbsp;any&nbsp;sides&nbsp;we&nbsp;need&nbsp;to&nbsp;evaluate,&nbsp;finds&nbsp;the&nbsp;new&nbsp;headways<br>
(new&nbsp;vehicle&nbsp;headway,&nbsp;new&nbsp;lcside&nbsp;follower&nbsp;headway).<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;to&nbsp;have&nbsp;their&nbsp;lane&nbsp;changing&nbsp;model&nbsp;called.<br>
&nbsp;&nbsp;&nbsp;&nbsp;chk_lc:&nbsp;float&nbsp;between&nbsp;0&nbsp;and&nbsp;1&nbsp;which&nbsp;gives&nbsp;the&nbsp;probability&nbsp;of&nbsp;checking&nbsp;the&nbsp;lane&nbsp;changing&nbsp;model<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;the&nbsp;vehicle&nbsp;is&nbsp;in&nbsp;a&nbsp;discretionary&nbsp;state.<br>
&nbsp;&nbsp;&nbsp;&nbsp;get_fol:&nbsp;if&nbsp;True,&nbsp;we&nbsp;also&nbsp;find&nbsp;the&nbsp;new&nbsp;follower&nbsp;headway.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool:&nbsp;True&nbsp;if&nbsp;we&nbsp;want&nbsp;to&nbsp;call&nbsp;the&nbsp;lane&nbsp;changing&nbsp;model.<br>
&nbsp;&nbsp;&nbsp;&nbsp;tuple&nbsp;of&nbsp;floats:&nbsp;(lside,&nbsp;rside,&nbsp;newlfolhd,&nbsp;newlhd,&nbsp;newrfolhd,&nbsp;newrhd,&nbsp;newfolhd).&nbsp;lside/rside<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;bools&nbsp;which&nbsp;are&nbsp;True&nbsp;if&nbsp;we&nbsp;need&nbsp;to&nbsp;check&nbsp;that&nbsp;side&nbsp;in&nbsp;the&nbsp;LC&nbsp;model.&nbsp;rest&nbsp;are&nbsp;float&nbsp;headways,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;giving&nbsp;the&nbsp;new&nbsp;headway&nbsp;for&nbsp;that&nbsp;vehicle.&nbsp;If&nbsp;get_fol&nbsp;=&nbsp;False,&nbsp;newfolhd&nbsp;is&nbsp;not&nbsp;present.</tt></dd></dl>
 <dl><dt><a name="-set_route_events"><strong>set_route_events</strong></a>(veh)</dt><dd><tt>When&nbsp;a&nbsp;vehicle&nbsp;enters&nbsp;a&nbsp;new&nbsp;lane,&nbsp;this&nbsp;function&nbsp;generates&nbsp;all&nbsp;its&nbsp;route&nbsp;events&nbsp;for&nbsp;that&nbsp;lane.<br>
&nbsp;<br>
Every&nbsp;<a href="#Lane">Lane</a>&nbsp;has&nbsp;a&nbsp;list&nbsp;of&nbsp;'route&nbsp;events'&nbsp;defined&nbsp;for&nbsp;it,&nbsp;which&nbsp;ensure&nbsp;that&nbsp;the&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;follows&nbsp;its<br>
specified&nbsp;route.&nbsp;Refer&nbsp;to&nbsp;update_route&nbsp;for&nbsp;a&nbsp;description&nbsp;of&nbsp;route&nbsp;events,&nbsp;and&nbsp;make_cur_route&nbsp;for<br>
a&nbsp;description&nbsp;of&nbsp;the&nbsp;route&nbsp;model.<br>
If&nbsp;a&nbsp;vehicle&nbsp;enters&nbsp;a&nbsp;new&nbsp;road,&nbsp;this&nbsp;function&nbsp;will&nbsp;generate&nbsp;the&nbsp;cur_route&nbsp;for&nbsp;that&nbsp;road&nbsp;and&nbsp;a&nbsp;subset<br>
of&nbsp;its&nbsp;lanes.&nbsp;This&nbsp;function&nbsp;will&nbsp;pop&nbsp;from&nbsp;the&nbsp;vehicle's&nbsp;route&nbsp;when&nbsp;that&nbsp;occurs.&nbsp;The&nbsp;exception&nbsp;to&nbsp;this<br>
is&nbsp;when&nbsp;vehicles&nbsp;are&nbsp;first&nbsp;initialized,&nbsp;the&nbsp;initialize&nbsp;method&nbsp;of&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;creates&nbsp;the&nbsp;first<br>
cur_route,&nbsp;and&nbsp;therefore&nbsp;pops&nbsp;from&nbsp;the&nbsp;route&nbsp;the&nbsp;first&nbsp;time.<br>
If&nbsp;a&nbsp;vehicle&nbsp;enters&nbsp;a&nbsp;new&nbsp;lane&nbsp;on&nbsp;the&nbsp;same&nbsp;road,&nbsp;it&nbsp;will&nbsp;either&nbsp;get&nbsp;the&nbsp;existing&nbsp;route<br>
from&nbsp;cur_route,&nbsp;or&nbsp;if&nbsp;the&nbsp;route&nbsp;for&nbsp;the&nbsp;new&nbsp;lane&nbsp;does&nbsp;not&nbsp;exist,&nbsp;it&nbsp;will&nbsp;create&nbsp;it&nbsp;add&nbsp;the&nbsp;key/value<br>
to&nbsp;cur_route.&nbsp;When&nbsp;creating&nbsp;a&nbsp;route&nbsp;for&nbsp;a&nbsp;new&nbsp;lane&nbsp;on&nbsp;the&nbsp;same&nbsp;road,&nbsp;it&nbsp;uses&nbsp;make_route_helper.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;which&nbsp;we&nbsp;will&nbsp;set&nbsp;its&nbsp;current&nbsp;route_events&nbsp;for.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;veh&nbsp;attributes&nbsp;in&nbsp;place&nbsp;(route_events,&nbsp;cur_route,&nbsp;possibly&nbsp;applies&nbsp;route&nbsp;events).</tt></dd></dl>
 <dl><dt><a name="-shift_speed"><strong>shift_speed</strong></a>(speed_series, shift, dt)</dt><dd><tt>Given&nbsp;series&nbsp;of&nbsp;speeds,&nbsp;returns&nbsp;the&nbsp;speed&nbsp;shifted&nbsp;by&nbsp;'shift'&nbsp;amount&nbsp;of&nbsp;time.<br>
&nbsp;<br>
speed_series&nbsp;is&nbsp;a&nbsp;list&nbsp;speeds&nbsp;with&nbsp;constant&nbsp;discretization&nbsp;dt.&nbsp;We&nbsp;assume&nbsp;that&nbsp;the&nbsp;last&nbsp;entry&nbsp;in<br>
speed_series&nbsp;is&nbsp;the&nbsp;current&nbsp;speed,&nbsp;and&nbsp;we&nbsp;want&nbsp;the&nbsp;speed&nbsp;from&nbsp;shift&nbsp;time&nbsp;ago.&nbsp;If&nbsp;shift&nbsp;is&nbsp;not&nbsp;a&nbsp;multiple<br>
of&nbsp;dt,&nbsp;we&nbsp;use&nbsp;linear&nbsp;interpolation&nbsp;between&nbsp;the&nbsp;two&nbsp;nearest&nbsp;speeds.&nbsp;If&nbsp;shift&nbsp;time&nbsp;ago&nbsp;is&nbsp;before&nbsp;the<br>
earliest&nbsp;measurement&nbsp;in&nbsp;speed_series,&nbsp;we&nbsp;return&nbsp;the&nbsp;first&nbsp;entry&nbsp;in&nbsp;speed_series.<br>
Returns&nbsp;a&nbsp;speed.</tt></dd></dl>
 <dl><dt><a name="-shifted_speed_inflow"><strong>shifted_speed_inflow</strong></a>(curlane, dt, shift=1, accel_bound=-2)</dt><dd><tt>Extra&nbsp;condition&nbsp;for&nbsp;upstream&nbsp;boundary&nbsp;based&nbsp;on&nbsp;Newell&nbsp;model&nbsp;and&nbsp;a&nbsp;vehicle's&nbsp;car&nbsp;following&nbsp;model.<br>
&nbsp;<br>
We&nbsp;get&nbsp;the&nbsp;first&nbsp;speed&nbsp;for&nbsp;the&nbsp;vehicle&nbsp;based&nbsp;on&nbsp;the&nbsp;shifted&nbsp;speed&nbsp;of&nbsp;the&nbsp;lead&nbsp;vehicle&nbsp;(similar&nbsp;to&nbsp;Newell<br>
model).&nbsp;Then&nbsp;we&nbsp;compute&nbsp;the&nbsp;vehicle's&nbsp;acceleration&nbsp;using&nbsp;its&nbsp;own&nbsp;car&nbsp;following&nbsp;model.&nbsp;If&nbsp;the&nbsp;acceleration<br>
is&nbsp;too&nbsp;negative,&nbsp;we&nbsp;don't&nbsp;add&nbsp;it&nbsp;to&nbsp;the&nbsp;simulation.&nbsp;If&nbsp;we&nbsp;add&nbsp;it,&nbsp;it's&nbsp;with&nbsp;the&nbsp;shifted&nbsp;leader&nbsp;speed.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;curlane:&nbsp;<a href="#Lane">Lane</a>&nbsp;with&nbsp;upstream&nbsp;boundary&nbsp;condition,&nbsp;which&nbsp;will&nbsp;possibly&nbsp;have&nbsp;a&nbsp;vehicle&nbsp;added.<br>
&nbsp;&nbsp;&nbsp;&nbsp;dt:&nbsp;timestep<br>
&nbsp;&nbsp;&nbsp;&nbsp;shift:&nbsp;amount&nbsp;(time)&nbsp;to&nbsp;shift&nbsp;the&nbsp;leader's&nbsp;speed&nbsp;by<br>
&nbsp;&nbsp;&nbsp;&nbsp;accel_bound:&nbsp;minimum&nbsp;acceleration&nbsp;a&nbsp;vehicle&nbsp;can&nbsp;be&nbsp;added&nbsp;with<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;The&nbsp;vehicle&nbsp;is&nbsp;not&nbsp;to&nbsp;be&nbsp;added,&nbsp;we&nbsp;return&nbsp;None.&nbsp;Otherwise,&nbsp;we&nbsp;return&nbsp;the&nbsp;(pos,&nbsp;spd,&nbsp;hd)&nbsp;for&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehicle&nbsp;to&nbsp;be&nbsp;added&nbsp;with.</tt></dd></dl>
 <dl><dt><a name="-speed_inflow"><strong>speed_inflow</strong></a>(curlane, speed_series, timeind, dt, accel_bound=-2)</dt><dd><tt>Like&nbsp;shifted_speed_inflow,&nbsp;but&nbsp;gets&nbsp;speed&nbsp;from&nbsp;speed_series&nbsp;instead&nbsp;of&nbsp;the&nbsp;shifted&nbsp;leader&nbsp;speed.</tt></dd></dl>
 <dl><dt><a name="-timeseries_wrapper"><strong>timeseries_wrapper</strong></a>(timeseries, starttimeind=0)</dt><dd><tt>Decorator&nbsp;to&nbsp;convert&nbsp;a&nbsp;list&nbsp;or&nbsp;numpy&nbsp;array&nbsp;into&nbsp;a&nbsp;function&nbsp;which&nbsp;accepts&nbsp;a&nbsp;timeind.</tt></dd></dl>
 <dl><dt><a name="-update_change"><strong>update_change</strong></a>(lc_actions, veh, timeind)</dt><dd><tt>When&nbsp;a&nbsp;vehicle&nbsp;changes&nbsp;lanes,&nbsp;this&nbsp;function&nbsp;does&nbsp;all&nbsp;the&nbsp;necessary&nbsp;updates.<br>
&nbsp;<br>
When&nbsp;a&nbsp;vehicle&nbsp;changes&nbsp;lanes,&nbsp;we&nbsp;need&nbsp;to&nbsp;update&nbsp;it's&nbsp;lane,&nbsp;road,&nbsp;llane/rlane,&nbsp;r/l_lc,&nbsp;lanemem,<br>
lc_side,&nbsp;coop_veh,&nbsp;lc_urgency&nbsp;attributes.<br>
More&nbsp;importantly,&nbsp;we&nbsp;need&nbsp;to&nbsp;update&nbsp;all&nbsp;the&nbsp;leader/follower&nbsp;relationships.<br>
***Naming&nbsp;conventions***<br>
Every&nbsp;vehicle&nbsp;has&nbsp;its&nbsp;leader&nbsp;(lead)&nbsp;and&nbsp;follower&nbsp;(fol).&nbsp;Putting&nbsp;l&nbsp;or&nbsp;r&nbsp;in&nbsp;front&nbsp;of&nbsp;lead/fol&nbsp;indicates<br>
that&nbsp;it&nbsp;is&nbsp;the&nbsp;left/right&nbsp;leader/follower.&nbsp;Consider&nbsp;some&nbsp;vehicle,&nbsp;the&nbsp;'ego&nbsp;vehicle'.&nbsp;The&nbsp;ego&nbsp;vehicle's<br>
lfol&nbsp;is&nbsp;the&nbsp;vehicle&nbsp;in&nbsp;the&nbsp;left&nbsp;lane&nbsp;closest&nbsp;to&nbsp;the&nbsp;ego&nbsp;vehicle,&nbsp;without&nbsp;going&nbsp;past&nbsp;the&nbsp;position&nbsp;of&nbsp;the<br>
ego&nbsp;vehicle.&nbsp;llead&nbsp;has&nbsp;two&nbsp;possible&nbsp;meanings.&nbsp;The&nbsp;llead&nbsp;attribute&nbsp;is&nbsp;the&nbsp;set&nbsp;of&nbsp;all&nbsp;vehicles&nbsp;which<br>
have&nbsp;the&nbsp;ego&nbsp;vehicle&nbsp;as&nbsp;a&nbsp;rfol.&nbsp;In&nbsp;the&nbsp;context&nbsp;of&nbsp;a&nbsp;lane&nbsp;changing&nbsp;model,&nbsp;we&nbsp;use&nbsp;llead&nbsp;to&nbsp;refer&nbsp;to&nbsp;the<br>
leader&nbsp;of&nbsp;lfol.&nbsp;Note&nbsp;that&nbsp;the&nbsp;leader&nbsp;of&nbsp;lfol&nbsp;is&nbsp;not&nbsp;even&nbsp;necessarily&nbsp;in&nbsp;the&nbsp;set&nbsp;which&nbsp;defines<br>
the&nbsp;llead&nbsp;attribute.<br>
The&nbsp;same&nbsp;definitions&nbsp;apply&nbsp;to&nbsp;rfol&nbsp;and&nbsp;rlead&nbsp;as&nbsp;to&nbsp;lfol&nbsp;and&nbsp;llead.<br>
The&nbsp;other&nbsp;naming&nbsp;conventions&nbsp;are&nbsp;lcside,&nbsp;newlcside,&nbsp;and&nbsp;opside.&nbsp;If&nbsp;a&nbsp;vehicle&nbsp;changes&nbsp;to&nbsp;the&nbsp;left,<br>
lcside&nbsp;(lane&nbsp;change&nbsp;side)&nbsp;refers&nbsp;to&nbsp;the&nbsp;left&nbsp;lane,&nbsp;the&nbsp;opside&nbsp;(opposite&nbsp;lane&nbsp;change&nbsp;side)&nbsp;refers&nbsp;to<br>
the&nbsp;right&nbsp;lane.&nbsp;The&nbsp;newlcside&nbsp;(new&nbsp;lane&nbsp;change&nbsp;side)&nbsp;is&nbsp;the&nbsp;new&nbsp;lcside&nbsp;after&nbsp;changing&nbsp;lanes,&nbsp;so&nbsp;if&nbsp;the<br>
side&nbsp;is&nbsp;left,&nbsp;it&nbsp;refers&nbsp;to&nbsp;two&nbsp;lanes&nbsp;to&nbsp;the&nbsp;left.<br>
Note&nbsp;in&nbsp;this&nbsp;case&nbsp;we&nbsp;are&nbsp;using&nbsp;'new'&nbsp;to&nbsp;refer&nbsp;to&nbsp;the&nbsp;situation&nbsp;after&nbsp;the&nbsp;lane&nbsp;change.&nbsp;This&nbsp;is&nbsp;another<br>
convention&nbsp;used&nbsp;for&nbsp;lane&nbsp;changing&nbsp;models.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;lc_actions:&nbsp;dictionary&nbsp;with&nbsp;keys&nbsp;as&nbsp;vehicles&nbsp;which&nbsp;request&nbsp;lane&nbsp;changes&nbsp;in&nbsp;the&nbsp;current&nbsp;timestep,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values&nbsp;are&nbsp;a&nbsp;string&nbsp;either&nbsp;'l'&nbsp;or&nbsp;'r'&nbsp;which&nbsp;indicates&nbsp;the&nbsp;side&nbsp;of&nbsp;the&nbsp;change<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;which&nbsp;changes&nbsp;lanes,&nbsp;and&nbsp;has&nbsp;a&nbsp;key/value&nbsp;in&nbsp;lc_actions<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind:&nbsp;int&nbsp;giving&nbsp;the&nbsp;timestep&nbsp;of&nbsp;the&nbsp;simulation&nbsp;(0&nbsp;indexed)<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;veh,&nbsp;and&nbsp;all&nbsp;vehicles&nbsp;which&nbsp;have&nbsp;a&nbsp;relationship&nbsp;with&nbsp;veh,&nbsp;in&nbsp;place.</tt></dd></dl>
 <dl><dt><a name="-update_lane_events"><strong>update_lane_events</strong></a>(veh, timeind, remove_vehicles)</dt><dd><tt>Check&nbsp;if&nbsp;the&nbsp;next&nbsp;event&nbsp;from&nbsp;a&nbsp;<a href="#Vehicle">Vehicle</a>'s&nbsp;lane_events&nbsp;should&nbsp;be&nbsp;applied,&nbsp;and&nbsp;apply&nbsp;it&nbsp;if&nbsp;so.<br>
&nbsp;<br>
lane_events&nbsp;are&nbsp;a&nbsp;list&nbsp;of&nbsp;events&nbsp;which&nbsp;handle&nbsp;anything&nbsp;related&nbsp;to&nbsp;the&nbsp;network&nbsp;topology,<br>
i.e.&nbsp;when&nbsp;the&nbsp;current&nbsp;lane&nbsp;ends,&nbsp;or&nbsp;when&nbsp;the&nbsp;current&nbsp;lane's&nbsp;left&nbsp;or&nbsp;right&nbsp;connections&nbsp;change.<br>
Each&nbsp;event&nbsp;is&nbsp;a&nbsp;dictionary&nbsp;with&nbsp;the&nbsp;keys&nbsp;of<br>
'pos':&nbsp;the&nbsp;float&nbsp;position&nbsp;the&nbsp;event&nbsp;occurs&nbsp;(relative&nbsp;to&nbsp;the&nbsp;vehicle's&nbsp;current&nbsp;lane)<br>
'event':&nbsp;one&nbsp;of<br>
&nbsp;&nbsp;&nbsp;&nbsp;'new&nbsp;lane'&nbsp;-&nbsp;occurs&nbsp;when&nbsp;a&nbsp;vehicle&nbsp;reaches&nbsp;the&nbsp;end&nbsp;of&nbsp;its&nbsp;current&nbsp;lane&nbsp;and&nbsp;transitions&nbsp;to&nbsp;a&nbsp;new&nbsp;lane<br>
&nbsp;&nbsp;&nbsp;&nbsp;'update&nbsp;lr'&nbsp;-&nbsp;occurs&nbsp;when&nbsp;the&nbsp;current&nbsp;lane's&nbsp;left&nbsp;or&nbsp;right&nbsp;connections&nbsp;change<br>
&nbsp;&nbsp;&nbsp;&nbsp;'exit'&nbsp;-&nbsp;occurs&nbsp;when&nbsp;a&nbsp;vehicle&nbsp;reaches&nbsp;the&nbsp;end&nbsp;of&nbsp;its&nbsp;current&nbsp;lane&nbsp;and&nbsp;exits&nbsp;the&nbsp;road&nbsp;network<br>
'left':&nbsp;for&nbsp;'new&nbsp;lane'&nbsp;or&nbsp;'update&nbsp;lr',&nbsp;if&nbsp;the&nbsp;left&nbsp;connection&nbsp;changes,&nbsp;'left'&nbsp;needs&nbsp;a&nbsp;value&nbsp;of&nbsp;either<br>
&nbsp;&nbsp;&nbsp;&nbsp;'add'&nbsp;if&nbsp;there&nbsp;is&nbsp;a&nbsp;new&nbsp;left&nbsp;lane,&nbsp;or&nbsp;'remove'&nbsp;if&nbsp;the&nbsp;current&nbsp;left&nbsp;connection&nbsp;is&nbsp;no&nbsp;longer&nbsp;possible<br>
'left&nbsp;anchor':&nbsp;if&nbsp;'left'&nbsp;is&nbsp;'add',&nbsp;'left&nbsp;anchor'&nbsp;is&nbsp;an&nbsp;index&nbsp;giving&nbsp;the&nbsp;merge&nbsp;anchor&nbsp;for&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;left&nbsp;lane<br>
'right':&nbsp;same&nbsp;as&nbsp;left,&nbsp;for&nbsp;right&nbsp;side<br>
'right&nbsp;anchor':&nbsp;same&nbsp;as&nbsp;left&nbsp;anchor,&nbsp;for&nbsp;right&nbsp;side<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;update<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind:&nbsp;int&nbsp;giving&nbsp;the&nbsp;timestep&nbsp;of&nbsp;the&nbsp;simulation&nbsp;(0&nbsp;indexed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;remove_vehicles:&nbsp;set&nbsp;of&nbsp;vehicles&nbsp;which&nbsp;will&nbsp;be&nbsp;removed&nbsp;from&nbsp;simulation&nbsp;at&nbsp;current&nbsp;timestep<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;attributes&nbsp;in&nbsp;place,&nbsp;adds&nbsp;to&nbsp;remove_vehicles&nbsp;in&nbsp;place.</tt></dd></dl>
 <dl><dt><a name="-update_lane_lr"><strong>update_lane_lr</strong></a>(veh, curlane, curevent)</dt><dd><tt>Updates&nbsp;a&nbsp;vehicle's&nbsp;attributes&nbsp;when&nbsp;its&nbsp;lane&nbsp;changes&nbsp;its&nbsp;left/right&nbsp;connections.<br>
&nbsp;<br>
For&nbsp;a&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;veh&nbsp;which&nbsp;reaches&nbsp;a&nbsp;point&nbsp;where&nbsp;its&nbsp;curlane.get_connect_left&nbsp;or&nbsp;get_connect_right<br>
go&nbsp;from&nbsp;None&nbsp;to&nbsp;some&nbsp;<a href="#Lane">Lane</a>,&nbsp;or&nbsp;some&nbsp;<a href="#Lane">Lane</a>&nbsp;to&nbsp;None,&nbsp;there&nbsp;needs&nbsp;to&nbsp;be&nbsp;'add'&nbsp;or&nbsp;'remove'&nbsp;events&nbsp;for&nbsp;the<br>
corresponding&nbsp;sides.&nbsp;This&nbsp;handles&nbsp;those&nbsp;events.<br>
Updates&nbsp;the&nbsp;vehicle&nbsp;orders&nbsp;and&nbsp;defaults&nbsp;the&nbsp;lane&nbsp;change&nbsp;states&nbsp;to&nbsp;the&nbsp;correct&nbsp;behavior&nbsp;(by&nbsp;default,<br>
enter&nbsp;discretionary&nbsp;only&nbsp;if&nbsp;the&nbsp;left/right&nbsp;lane&nbsp;is&nbsp;in&nbsp;the&nbsp;same&nbsp;road&nbsp;as&nbsp;the&nbsp;current&nbsp;lane)<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;update<br>
&nbsp;&nbsp;&nbsp;&nbsp;curlane:&nbsp;the&nbsp;<a href="#Lane">Lane</a>&nbsp;veh&nbsp;is&nbsp;currently&nbsp;on,&nbsp;curlane&nbsp;has&nbsp;the&nbsp;new/ending&nbsp;connections<br>
&nbsp;&nbsp;&nbsp;&nbsp;curevent:&nbsp;The&nbsp;event&nbsp;(dictionary)&nbsp;triggering&nbsp;the&nbsp;update<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;veh&nbsp;attributes&nbsp;in&nbsp;place.</tt></dd></dl>
 <dl><dt><a name="-update_leadfol_after_lc"><strong>update_leadfol_after_lc</strong></a>(veh, lcsidelane, newlcsidelane, side, timeind)</dt><dd><tt>Logic&nbsp;for&nbsp;updating&nbsp;all&nbsp;the&nbsp;leader/follower&nbsp;relationships&nbsp;for&nbsp;veh&nbsp;following&nbsp;a&nbsp;lane&nbsp;change.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;which&nbsp;changed&nbsp;lanes.<br>
&nbsp;&nbsp;&nbsp;&nbsp;lcsidelane:&nbsp;The&nbsp;new&nbsp;lane&nbsp;veh&nbsp;changed&nbsp;onto.<br>
&nbsp;&nbsp;&nbsp;&nbsp;newlcsidelane:&nbsp;The&nbsp;new&nbsp;lane&nbsp;on&nbsp;the&nbsp;lane&nbsp;change&nbsp;side&nbsp;for&nbsp;veh.<br>
&nbsp;&nbsp;&nbsp;&nbsp;side:&nbsp;side&nbsp;of&nbsp;lane&nbsp;change,&nbsp;either&nbsp;left&nbsp;('l')&nbsp;or&nbsp;right&nbsp;('r').<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind:&nbsp;int&nbsp;giving&nbsp;the&nbsp;timestep&nbsp;of&nbsp;the&nbsp;simulation&nbsp;(0&nbsp;indexed)<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;veh&nbsp;and&nbsp;any&nbsp;vehicles&nbsp;which&nbsp;have&nbsp;leader/follower&nbsp;relationships&nbsp;with&nbsp;veh&nbsp;in&nbsp;place.</tt></dd></dl>
 <dl><dt><a name="-update_lrfol"><strong>update_lrfol</strong></a>(veh)</dt><dd><tt>After&nbsp;a&nbsp;vehicle's&nbsp;state&nbsp;has&nbsp;been&nbsp;updated,&nbsp;this&nbsp;updates&nbsp;its&nbsp;lfol/rfol.<br>
&nbsp;<br>
We&nbsp;keep&nbsp;each&nbsp;vehicle's&nbsp;left/right&nbsp;followers&nbsp;updated&nbsp;by&nbsp;doing&nbsp;a&nbsp;single&nbsp;distance&nbsp;compute&nbsp;each&nbsp;timestep.<br>
The&nbsp;current&nbsp;way&nbsp;of&nbsp;dealing&nbsp;with&nbsp;l/r&nbsp;followers&nbsp;is&nbsp;designed&nbsp;for&nbsp;timesteps&nbsp;which&nbsp;are&nbsp;relatively&nbsp;small.<br>
(e.g.&nbsp;.1&nbsp;or&nbsp;.25&nbsp;seconds).&nbsp;Other&nbsp;strategies&nbsp;would&nbsp;be&nbsp;better&nbsp;for&nbsp;larger&nbsp;timesteps.&nbsp;See&nbsp;block&nbsp;comment<br>
above&nbsp;update_change&nbsp;to&nbsp;discuss&nbsp;alternative&nbsp;strategies&nbsp;for&nbsp;defining&nbsp;leader/follower&nbsp;relationships.<br>
See&nbsp;update_change&nbsp;documentation&nbsp;for&nbsp;explanation&nbsp;of&nbsp;naming&nbsp;conventions.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;to&nbsp;check&nbsp;its&nbsp;lfol/rfol&nbsp;to&nbsp;be&nbsp;updated.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;veh&nbsp;attributes,&nbsp;attributes&nbsp;of&nbsp;its&nbsp;lfol/rfol,&nbsp;in&nbsp;place.</tt></dd></dl>
 <dl><dt><a name="-update_merge_anchors"><strong>update_merge_anchors</strong></a>(curlane, lc_actions)</dt><dd><tt>Updates&nbsp;merge_anchors&nbsp;attribute&nbsp;for&nbsp;curlane.<br>
&nbsp;<br>
Lanes&nbsp;have&nbsp;lists&nbsp;of&nbsp;merge&nbsp;anchors,&nbsp;they&nbsp;are&nbsp;used&nbsp;as&nbsp;guesses&nbsp;for&nbsp;leadfol_find&nbsp;for&nbsp;'new&nbsp;lane'&nbsp;or<br>
'update&nbsp;lanes'&nbsp;events&nbsp;when&nbsp;a&nbsp;left&nbsp;or&nbsp;right&nbsp;lane&nbsp;is&nbsp;added.&nbsp;Thus,&nbsp;merge&nbsp;anchors&nbsp;are&nbsp;used&nbsp;to&nbsp;ensure<br>
the&nbsp;leader/follower&nbsp;relationships&nbsp;are&nbsp;updated&nbsp;correctly&nbsp;when&nbsp;the&nbsp;network&nbsp;topology&nbsp;changes.<br>
A&nbsp;merge&nbsp;anchor&nbsp;is&nbsp;defined&nbsp;as&nbsp;a&nbsp;(vehicle,&nbsp;position)&nbsp;tuple.&nbsp;vehicle&nbsp;can&nbsp;be&nbsp;either&nbsp;an&nbsp;anchor&nbsp;or&nbsp;normal<br>
vehicle.&nbsp;position&nbsp;can&nbsp;be&nbsp;either&nbsp;None&nbsp;or&nbsp;a&nbsp;float&nbsp;position.&nbsp;If&nbsp;position&nbsp;is&nbsp;None,&nbsp;vehicle&nbsp;is&nbsp;an&nbsp;anchor,<br>
and&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;be&nbsp;updated.&nbsp;Otherwise,&nbsp;position&nbsp;is&nbsp;a&nbsp;float&nbsp;of&nbsp;the&nbsp;position&nbsp;on&nbsp;curlane,<br>
and&nbsp;the&nbsp;merge&nbsp;anchor&nbsp;is&nbsp;the&nbsp;vehicle&nbsp;on&nbsp;the&nbsp;same&nbsp;track&nbsp;as&nbsp;curlane&nbsp;which&nbsp;is&nbsp;closest&nbsp;to&nbsp;position&nbsp;without<br>
yet&nbsp;passing&nbsp;position.<br>
position&nbsp;being&nbsp;None&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;situation&nbsp;where&nbsp;a&nbsp;new&nbsp;lane&nbsp;starts.<br>
position&nbsp;being&nbsp;a&nbsp;float&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;situation&nbsp;where&nbsp;two&nbsp;lanes&nbsp;initially&nbsp;meet.<br>
Unlike&nbsp;lfol/rfol,&nbsp;merge&nbsp;anchors&nbsp;do&nbsp;not&nbsp;need&nbsp;to&nbsp;be&nbsp;completely&nbsp;updated.&nbsp;They&nbsp;should&nbsp;be&nbsp;kept<br>
in&nbsp;the&nbsp;same&nbsp;track&nbsp;as&nbsp;curlane&nbsp;however.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;curlane:&nbsp;<a href="#Lane">Lane</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;update<br>
&nbsp;&nbsp;&nbsp;&nbsp;lc_actions:&nbsp;dictionary&nbsp;with&nbsp;keys&nbsp;as&nbsp;vehicles&nbsp;which&nbsp;request&nbsp;lane&nbsp;changes&nbsp;in&nbsp;the&nbsp;current&nbsp;timestep,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values&nbsp;are&nbsp;a&nbsp;string&nbsp;either&nbsp;'l'&nbsp;or&nbsp;'r'&nbsp;which&nbsp;indicates&nbsp;the&nbsp;side&nbsp;of&nbsp;the&nbsp;change<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;merge_anchors&nbsp;attribute&nbsp;for&nbsp;curlane</tt></dd></dl>
 <dl><dt><a name="-update_net"><strong>update_net</strong></a>(vehicles, lc_actions, inflow_lanes, merge_lanes, vehid, timeind, dt)</dt><dd><tt>Updates&nbsp;all&nbsp;quantities&nbsp;for&nbsp;a&nbsp;road&nbsp;network.<br>
&nbsp;<br>
After&nbsp;evaluating&nbsp;all&nbsp;vehicle's&nbsp;longitudinal&nbsp;and&nbsp;latitudinal&nbsp;actions,&nbsp;this&nbsp;function&nbsp;does&nbsp;the&nbsp;rest<br>
of&nbsp;the&nbsp;updates.&nbsp;In&nbsp;order:<br>
&nbsp;&nbsp;&nbsp;&nbsp;completeing&nbsp;requested&nbsp;lane&nbsp;changes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-moving&nbsp;vehicle&nbsp;to&nbsp;new&nbsp;lane&nbsp;and&nbsp;setting&nbsp;its&nbsp;new&nbsp;route/lane&nbsp;events<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-updating&nbsp;all&nbsp;leader/follower&nbsp;relationships&nbsp;(including&nbsp;l/rfol)&nbsp;for&nbsp;all&nbsp;vehicles&nbsp;involved<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-possibly&nbsp;applying&nbsp;relaxation<br>
&nbsp;&nbsp;&nbsp;&nbsp;updating&nbsp;state&nbsp;and&nbsp;memory<br>
&nbsp;&nbsp;&nbsp;&nbsp;updating&nbsp;all&nbsp;leader/follower&nbsp;relationships&nbsp;(also&nbsp;updates&nbsp;merge&nbsp;anchors)<br>
&nbsp;&nbsp;&nbsp;&nbsp;updating&nbsp;all&nbsp;vehicles&nbsp;lane/route&nbsp;events&nbsp;(including&nbsp;possibly&nbsp;removing&nbsp;vehicles)<br>
&nbsp;&nbsp;&nbsp;&nbsp;updating&nbsp;inflow&nbsp;conditions&nbsp;for&nbsp;all&nbsp;lanes&nbsp;with&nbsp;inflow&nbsp;(including&nbsp;possibly&nbsp;adding&nbsp;new&nbsp;vehicles&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;generating&nbsp;the&nbsp;parameters&nbsp;for&nbsp;the&nbsp;next&nbsp;new&nbsp;vehicle)<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehicles:&nbsp;set&nbsp;containing&nbsp;all&nbsp;vehicle&nbsp;objects&nbsp;being&nbsp;actively&nbsp;simulated<br>
&nbsp;&nbsp;&nbsp;&nbsp;lc_actions:&nbsp;dictionary&nbsp;with&nbsp;keys&nbsp;as&nbsp;vehicles&nbsp;which&nbsp;request&nbsp;lane&nbsp;changes&nbsp;in&nbsp;the&nbsp;current&nbsp;timestep,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values&nbsp;are&nbsp;a&nbsp;string&nbsp;either&nbsp;'l'&nbsp;or&nbsp;'r'&nbsp;which&nbsp;indicates&nbsp;the&nbsp;side&nbsp;of&nbsp;the&nbsp;change<br>
&nbsp;&nbsp;&nbsp;&nbsp;inflow_lanes:&nbsp;iterable&nbsp;of&nbsp;lanes&nbsp;which&nbsp;have&nbsp;upstream&nbsp;(inflow)&nbsp;boundary&nbsp;conditions.&nbsp;These&nbsp;lanes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;must&nbsp;have&nbsp;get_inflow,&nbsp;increment_inflow,&nbsp;and&nbsp;new_vehicle&nbsp;methods<br>
&nbsp;&nbsp;&nbsp;&nbsp;merge_lanes:&nbsp;iterable&nbsp;of&nbsp;lanes&nbsp;which&nbsp;have&nbsp;merge&nbsp;anchors.&nbsp;These&nbsp;lanes&nbsp;must&nbsp;have&nbsp;a&nbsp;merge_anchors<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attribute<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehid:&nbsp;int&nbsp;giving&nbsp;the&nbsp;unique&nbsp;vehicle&nbsp;ID&nbsp;for&nbsp;the&nbsp;next&nbsp;vehicle&nbsp;to&nbsp;be&nbsp;generated<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind:&nbsp;int&nbsp;giving&nbsp;the&nbsp;timestep&nbsp;of&nbsp;the&nbsp;simulation&nbsp;(0&nbsp;indexed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;dt:&nbsp;float&nbsp;of&nbsp;time&nbsp;unit&nbsp;that&nbsp;passes&nbsp;in&nbsp;each&nbsp;timestep<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;vehid:&nbsp;updated&nbsp;int&nbsp;value&nbsp;of&nbsp;next&nbsp;vehicle&nbsp;ID&nbsp;to&nbsp;be&nbsp;added<br>
&nbsp;&nbsp;&nbsp;&nbsp;remove_vehicles:&nbsp;set&nbsp;of&nbsp;vehicles&nbsp;which&nbsp;were&nbsp;removed&nbsp;from&nbsp;simulation&nbsp;at&nbsp;current&nbsp;timestep<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Modifies&nbsp;vehicles&nbsp;in&nbsp;place&nbsp;(potentially&nbsp;all&nbsp;their&nbsp;non-parameter/bounds&nbsp;attributes,&nbsp;e.g.&nbsp;pos/spd,<br>
&nbsp;&nbsp;&nbsp;&nbsp;lead/fol&nbsp;relationships,&nbsp;their&nbsp;lane/roads,&nbsp;memory,&nbsp;etc.).</tt></dd></dl>
 <dl><dt><a name="-update_route"><strong>update_route</strong></a>(veh)</dt><dd><tt>Check&nbsp;if&nbsp;the&nbsp;next&nbsp;event&nbsp;from&nbsp;a&nbsp;vehicle's&nbsp;route_events&nbsp;should&nbsp;be&nbsp;applied,&nbsp;and&nbsp;apply&nbsp;it&nbsp;if&nbsp;so.<br>
&nbsp;<br>
route_events&nbsp;are&nbsp;a&nbsp;list&nbsp;of&nbsp;events&nbsp;which&nbsp;handles&nbsp;any&nbsp;lane&nbsp;changing&nbsp;behavior&nbsp;related&nbsp;to<br>
a&nbsp;vehicle's&nbsp;route,&nbsp;i.e.&nbsp;route&nbsp;events&nbsp;ensure&nbsp;that&nbsp;the&nbsp;vehicle&nbsp;follows&nbsp;its&nbsp;route.<br>
Each&nbsp;event&nbsp;is&nbsp;a&nbsp;dictionary&nbsp;with&nbsp;the&nbsp;keys&nbsp;of<br>
'pos':&nbsp;the&nbsp;float&nbsp;position&nbsp;the&nbsp;event&nbsp;occurs&nbsp;(relative&nbsp;to&nbsp;the&nbsp;vehicle's&nbsp;current&nbsp;lane).<br>
'event':&nbsp;'end&nbsp;discretionary'&nbsp;or&nbsp;'mandatory',&nbsp;which&nbsp;end&nbsp;discretionary&nbsp;or&nbsp;start&nbsp;mandatory<br>
&nbsp;&nbsp;&nbsp;&nbsp;lane&nbsp;changing&nbsp;states<br>
'side':&nbsp;'l'&nbsp;or&nbsp;'r'&nbsp;the&nbsp;side&nbsp;which&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;event<br>
'lc_urgency':&nbsp;only&nbsp;for&nbsp;a&nbsp;'mandatory'&nbsp;event,&nbsp;a&nbsp;tuple&nbsp;giving&nbsp;the&nbsp;position&nbsp;for&nbsp;0%&nbsp;and&nbsp;100%&nbsp;forced&nbsp;cooperation<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;update<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool:&nbsp;True&nbsp;if&nbsp;we&nbsp;made&nbsp;a&nbsp;change,&nbsp;to&nbsp;the&nbsp;route,&nbsp;False&nbsp;otherwise</tt></dd></dl>
 <dl><dt><a name="-update_veh_lane"><strong>update_veh_lane</strong></a>(veh, oldlane, newlane, timeind, side=None)</dt><dd><tt>When&nbsp;a&nbsp;vehicle&nbsp;enters&nbsp;a&nbsp;new&nbsp;lane,&nbsp;this&nbsp;updates&nbsp;the&nbsp;lane,&nbsp;road,&nbsp;pos,&nbsp;and&nbsp;lanemem&nbsp;attributes.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;veh:&nbsp;<a href="#Vehicle">Vehicle</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;update.<br>
&nbsp;&nbsp;&nbsp;&nbsp;oldlane:&nbsp;current&nbsp;<a href="#Lane">Lane</a>&nbsp;veh&nbsp;is&nbsp;on.<br>
&nbsp;&nbsp;&nbsp;&nbsp;newlane:&nbsp;The&nbsp;new&nbsp;<a href="#Lane">Lane</a>&nbsp;the&nbsp;vehicle&nbsp;is&nbsp;changing&nbsp;to.<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeind:&nbsp;int&nbsp;giving&nbsp;the&nbsp;timestep&nbsp;of&nbsp;the&nbsp;simulation&nbsp;(0&nbsp;indexed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;side:&nbsp;if&nbsp;side&nbsp;is&nbsp;not&nbsp;None,&nbsp;also&nbsp;updates&nbsp;the&nbsp;'r_lc'/'l_lc'&nbsp;attributes&nbsp;(if&nbsp;a&nbsp;vehicle&nbsp;changes&nbsp;to&nbsp;left,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;you&nbsp;need&nbsp;to&nbsp;update&nbsp;r_lc&nbsp;attribute,&nbsp;so&nbsp;pass&nbsp;'r_lc').&nbsp;The&nbsp;l/r&nbsp;attributes&nbsp;are&nbsp;set&nbsp;to&nbsp;discretionary<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;lane&nbsp;is&nbsp;in&nbsp;the&nbsp;same&nbsp;road<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.</tt></dd></dl>
</td></tr></table>
</body></html>